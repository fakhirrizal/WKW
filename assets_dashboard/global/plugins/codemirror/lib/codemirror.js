ºººººººººººº¼¼¼¼¼¼¼¼ûººûºººººļº¼¼¼¼¼¼¼¼ûºººººººº»»ļº»»»»»»»»»ºººººº»»»»»»»»»»»üü»ûººººººººººº¾¾ü»»»»»»»üÿ¾¾¾¾¾¾¾ü»»üĽüü»»»»»»»»ü»žü»»¸¸ù¸ù¸¸¸¸¸¸¸¸ù¸¸¸¸ù¸¸»»¸¸ùŻ¸»»ùù¸ùĺ¸ĺù¸¸ºùù¸¸ĺ¸¸¸ùù¸ùĺù¸¸¸ùüüººººùùù¸¸ĺ¸ùĺĺ¸¸ĺŻĺ¸¸ùù¼¼»»»»»¸ùù¸¼¼¼¼»»»»üĽĽ»»»¸¸¸¸ùù¶Ƹŷ´´ǹȺŷĶĶŷŷŷŷĶ¶¶ĺ»»üºº¹º¹º¹¹ºº¹żż¹»»ûüºĽþĽ¸¸ĶǹƸõõƸƸõĶĶĶŷŷĶĶ¶¶»»ü¹¹¹¹Ļú»»»»üüŷǹƸĶõŷŷõõõĶĶĶĶõ¶¸¸¸¸¸»»»¹¹¹¹¹»ü÷ƸŷĶĶĶĶĶõõõõõõõ¸¸¸¸ùù¸¸¸»ü»¹¹¹ú¹¹¸¸¶¶¶÷÷÷÷ĸ¶¶¶¶¶¶¶¶¸¸¸¸ùù¸¸¸ü»ºººûººûûºûººº»»»ù¸¶ĸĸ÷÷Źĸĸ÷÷÷÷ĸĸ¸¸¸¸¸»»ûººû»»üüüù¸÷ŹŹ¶ĸ÷÷¶¶¶¶÷÷»»»»»»üü¸¸¸ù¸¸¸¸ùù»»»»»»¸¸Ź¶¶ŹŹ¶»»»»üüĽĽ»Ľü¸ùùù¸¸ĺŻ¸¸¸¸ùùùùû»»»»¼ü½ý¿½ºû¼ýýý½¾¼½½¼¼ýý½¾ÿÿþûýý½½þ¿ſſúĻŽļ½ýÿſÿ¼ÿÿÿÿ½ÿ½þþ½½½ĿĿþþ½½þþþþ¼ľľſþƿǿǾȿƿ¼¼½¾ûļļûººûļļŽƽǾƽ¿¿ÿ¿¿ſſſľýýľľýýý¼¼¼ſľýýľľý¼ÿÿÿ¾¾¾¾¾ÿ½½¼ýýýľƽľƽƽǾĻ¹¹ºĻľǾý¼üľſſý¼ýýľľľľý¾¼¼ý¼¼ýý¼¼¼ú¹ý½½½½½»¹úüúü»»»ĽûûûĻºùúƽƼĹ··¹ĻŽżû¹¹º»üüüü»»»»»ü»ºººüü»¹»¸¸¸ùĺºº¾»»»ú¹¸ĺƼǽƼļû¹úº»ººûûûļºûûºž»üü»úúú»ļŽûººûûûº¸¸¸ùùĺĺĺùĺŻĺ¸¸ùü»»üü»»»üÿ¿½¾ſľĽüĻĻŻŻºĻĻĻ¹·¸¸öö¶¶¶¶¶÷÷÷÷÷öµµĵĵŶö¿¾ý½ýººúĻ¹úĻúûº¸¸¸÷÷÷÷÷÷¶¶ĶĶŷ÷¼ü¼¹¹¹¹¹¹¹¹úûû¸¸¸¸÷÷÷÷¶¶¶¶ŷ÷ÿÿþþ½½½ÿÿÿÿ¾ÿÿ¾¿¾ÿ¾þþþ¿ú¹¹ûļùùùù¸¸¸¸ù¸¸¸¶¶÷÷¶¶¶¶ŷ÷»»üüĽžžžžƿƿĽſſſľ¼¼¼ýý¾ÿ¼¹º¹ùùú¹¹ļļººººĺùùùĺùù¸¸÷¶ĸ÷÷÷÷÷÷ĸ¸¸¸ĺŽƼûĺļŻĻüĻĻü¹¹üý¼¾¼¼º»úºººĺĺú¹¹¹¹ûļººººĺĺĺĺĺĺùù¸¸÷÷Źĸĸ÷÷ĸĸŹ¹¹÷÷¶¶úŹ¶úƺùºĺ¸Żºùùù»üĽļºŽþĿ¾ÿ¾ûĽúúúûĺĺĺĺ¹¹¹¹¹úúúºººººĺĺĺùù¸¸¸ùùĸĸĸĸŹŹĹĹĹĹĹĹźźĹøƻǼŻùĺĺĺùĺŻǽĺùùŻƼŻùºûļŽŽļûººûļŽŽļºú»Ľƿſ½ÿ¾ÿ¾Ŀ¾ľ¼üĽúúûûŻŻĺĺ¹¹úúúú¹ºĺĺĺùùù¸¸ĺĺŹŹŹŹƺƺķ··¹ƹǿſǾſǾſǾſ½Ŀ¿¿ÿÿþþÿĿ½¿þƾȼźĹĺĻú¹¹ƽǾĺĺǼǻ¹ú¹¹¹úķ¸¸ƼȿȿŽû»üĽƿþĿſľſƿ¿ÿ¿þþþÿ½ĿĿĿŽǻźŻƽǾǾƽĻǾǾĻĺǼǻø¹¹ûķ¸¸¸¸¸¸¸¹Ļú¹úýľ¼»»û¼¾ĿĿþ¿¿ÿÿǾżļžſľſüüŽȾƼüĽžżļĻ¹¹û¸¸ù¸ŻŻĺĺù¸¸·ûý½½½Ŀ¿¿¿¿¿ÿ¿¿ľ½Ľ¾ýľľľľžƿƾľľľ¹úú¸ƽú¹úĻù¸¸ù¸ĺĺĺĺĺĺù¸úľĿ»ſýĿĿÿÿÿſ¾þ½¾¿¿úǿǿǿ¹ĺƽú¹úĻĻù¸¸ùù¸¸ùù¸»¼»»»ļǿſþžĿſſýþ½½þþ¾ÿýľſĿ¿ÿÿ¾ÿÿĿǿƾƾŽžžȿȿǾú¹¹úú¹ù¸¸ùùù¸¸ù¸ĺù¸»ü»ûûúúżƾŽ¼ú¼žƿýſĽ½ľſ½þþþþþ¿¿¿¿¾ÿÿûļûļü½½ĽĽüüżƽƽǾǾĻ¸úżĻ¹ù¸¸ùùù¸ĺ¸ùĺùùùùùùùûûúúżƽļºúľƿƿýſĽþĿþþ½þ¿¿¿¾¾ý¹ýÿ¿¿¹úĻżż¹¸żǾż¹ûºù¸÷·ø·źƻøµµǺƹķöĵĵŷŷµöµööµôôôĵĵŶôôĴĵĴĵóô²³ôĴŶ³ööû»º¹¹¶¶õ´µƷĸµöµµµŶŶĵĵĵŶƷƷ²²óóóóó²ƷŶô³³³ôô³ŶöööµûûûļĻĻĻĻ¸··¸ûĻƽƼƽǻĻ¶öķµööµµµööööööķķŸµµµµµǸƷŶĵôôµµöŸŸööķ¸ºº¹ú¹µ³úûļŽƽƽżżȾǽƻǼȽȽƺú¹úľ¸ƽǾ¸¹ʿǾɿǽŻúööķöµöµµµöµµµµµööķµµöķŸŸŸŸŶŶŶŶŶķŸƹŸƹŸŸŸŸùù¸¸¸¸·ø¹¹úĻļļļļƽƽǾżú··µµ³ô»üĽĽŽŽŽŽǾüü½ü»üþƿ¹ǽĽĻ¸ŽºķķöµķööµµµµµµµµµµµöķķķŸƹǺǺƹƹķķķķŸŸƹź···øĹĹĹź¹¹¹¹úúļļŽŽŽŽļļƽǾǾż¹öµµõĶüüüüļŽŽƾȿȿȿȿȿǾƽžþþĿĿĿĿþþþĿƾǿǿǿƾŽļûǾŽû¸ŸķöµµöŸķķöµµµµµķķöööķŸŸķķŸƹƹƹƹƹǺǺƹƹŸŸ···ĹĹøĹĻ¹¹¹¹úúúúļŽƾƾƾŽļûƽǾǾƽú··öµµĶĶļûººûŽƾżƽǾǾƽżżżľſſſýžžžĽļļǾǾżżĻûºùŸŸöµµķŸööµµööķķŸŸķķŸŸƹǺķŸƹƹƹƹƹŸŹŹŹĸĸ÷÷÷¹¹úºûļŽŽŽļûŻƼǾżúøøµµ¶ĶĶļûºļƾĻƽǾǾżĻĻżżƽýƽſǾľżľµſż¼úĻżƽǾƼĻĻ»¹ùŸŸöµµķƹµµµµöķŸƹŸŸŸķŸŸƹǺŸƹƹǺǺƹƹŸ÷÷÷ĸĸŹŹŹúú¹¹ûļŽŽļļ¸ùĻú·µµ¶Ķŷ´´´´´´´´´´´´´´õõ´´´õõõ´´´´´õõõõõ´´´´´õõõõõ´´´õõõõõ´õõ´´´¶¶¶¶¶¶¶°°°°´³´²²²²²²²²²²²ųųųĲĲĲĲĲƵƵƵƵƵƵƵƵ°°°°°°´´´´´´´³³³³³³³³³³³ųųųĲĲĲĲĲŴŴŴŴŴŴŴŴ±±±±±±±±´´´³³³³ĲĲĲųųųųųŴŴŴŴŴŴŴŴ±±±´´´³³³³³ĲĲĲųųųųƴŴŴŴŴŴŴŴŴ´´´´´´³³³³ôô³³³³³³³³ĲųųųųƴƴƴŴŴŴŴŴŴŴŴò´´´³³³³³ôôôôôôôôôôôųųųųųƴƴƴƵƵƵƵƵƵƵƵ±±±±´´³³³³ôôôôĵĵĵĵĵĵĵĵĴĴĴĴĴóóóŶŶŶŶŶŶŶŶ±±±ò±±±±±±ò´´´´õ³³³³ôôôôŶŶŶŶŶŶŶŶĴĴĴĴĴóóóŶŶŶŶŶŶŶŶȵȵȵȵȵȵȵȵƳǴǴǴǴǴȵȵǴƳŲŲŲƳǴȵŲŲƳǴǴƳŲŲǴǴƳƳǴǴȵȵɶȵǴƳƳǴȵɶǴǴǴǴǴȵȵɶʷʷɶɶɶȵȵȵ˸˸˸˸˸ʷɶȵɶɶʷ˸˸˸ʷʷȴɵɵʶ˷˷̸̸˷˷˷˷˷˷˷˷ʷʷʷ˸ʷʷɶȵ̹̹̹˸˸ʷʷʷͺ̹˸ɶɶʷ˸˸ʷʷʷʷʷʷʷʷǴǴǴǴǴǴǴǴƳǴǴǴǴȵȵȵǴǴƳƳƳǴǴǴƳƳǴǴǴǴǴǴǴǴǴǴǴǴȵɶȵȵǴǴǴǴȵȵȵǴǴǴǴȵɶɶɶɶɶȵȵȵȵȵɶɶʷʷʷʷʷɶɶɶʷ˸˸˸ʷʷʶ˷˷˷˷˷˷˷˷˷˷˷˷˷˷˷ʷʷ˸˸˸˸ʷʷ˸˸˸˸˸˸˸˸˸˸ʷɶɶɶɶʷʷʷʷʷʷʷʷʷŴŴŴŴŴŴŴŴŴŴŴŴŴƵƵƵŴŴŴƵŴŴŴĳŴŴŴŴŴƵǶǶƵŴŴŴŴƵǶǶƵƵƵǶǶƵƵƵȵȵǴǴȵȵɶɶɶɶɶȵȵȵȵȵǴȵɶʷʷ˸ʷʷɶʷʷ˸˸˸˸ʷ̸̸̸̸̸˷˷˷˷˷˷˷˷˷˷˷˸˸˸̹̹̹˸˸ʷʷ˸˸̹̹ͺͺʷ˸˸˸˸ʷɶɶ˸˸˸˸˸˸˸˸ĳĳĳĳĳĳĳĳŴŴŴŴƵƵƵƵŴƵƵǶǶƵĳĳƵŴĳĳŴƵǶȷƵƵƵŴƵƵǶȷŴƵǶȷȷǶƵŴɶȵȵȵȵɶɶʷɶɶɶɶɶɶɶɶȵɶʷʷ˸˸ʷʷɶʷʷ˸˸˸˸˸͹͹͹̸̸̸̸̸̸̸̸̸̸̸̸̸˸˸˸̹̹̹̹̹˸˸˸̹̹̹ͺͺ˸̹ͺͺͺ̹˸ʷ˸˸˸˸˸˸˸˸ĳĳĳĳĳĳĳĳŴŴŴƵƵƵƵǶŴƵǶǶǶƵŴĳƵŴĳĳŴƵǶȷǶƵƵƵƵǶȷȷƵǶȷȷȷȷǶƵɶɶȵȵɶɶʷʷʷʷʷʷʷʷʷʷ˸˸̹̹˸˸ʷɶʷʷ˸˸̹̹˸˸˷̸̸͹͹κκϻ͹͹͹͹͹͹͹͹˸˸˸˸˸̹̹̹ͺͺͺͺ̹̹̹̹̹̹ͺλͺ̹˸ʷ̹̹̹̹̹̹̹̹ŴŴŴŴŴŴŴŴŴƵƵƵƵǶǶǶƵǶǶǶǶǶƵƵƵŴŴŴƵƵǶȷǶǶǶƵǶǶȷɸǶǶȷȷȷȷǶǶʷɶɶɶɶʷ˸˸ʷʷ˸˸˸˸˸˸̹̹̹̹̹˸ʷɶʷʷ˸̹̹̹˸˸˷˷̸͹κκϻϻ͹͹͹͹͹͹͹͹̹̹˸˸˸̹̹̹λλλͺͺ̹̹̹̹̹̹̹̹̹˸˸̹̹̹̹̹̹̹̹ŴŴŴŴŴŴŴŴƵƵƵƵƵǶǶǶǶǶǶƵƵǶǶȷƵƵǶǶǶǶǶǶȷǶǶǶǶȷɸɸɸȷȷȷȷȷȷɸȷȷǶǶȷȷɸɸȷȷȷɸɸɸʹʹɸɸʹʹʹɸɸȷȷȷɸʹʹʹʹɸʹʹ˺˺˺̻̻̻˺˺˺˺˺˺˺˺˺˺˺ʹʹʹ˺˺̻̻̻̻˺˺˺˺˺˺ʹʹʹʹʹʹ˺˺˺˺˺˺˺˺ƵƵƵƵƵƵƵƵƵƵƵƵǶǶǶǶȷǶƵƵƵǶȷɸƵǶȷɸɸȷǶƵȷȷǶǶǶȷɸɸʹɸȷǶǶȷɸʹȷȷȷǶȷȷɸʹȷȷȷȷɸɸɸʹǶǶȷɸʹʹɸɸȷɸɸʹʹʹʹɸ̻̻˺˺˺˺˺˺̻̻̻̻̻̻̻̻ͼ̻˺˺˺˺˺˺ʹ˺˺˺̻̻ͼͼͼͼ˺ʹʹʹ˺̻˺˺˺˺˺˺˺˺ʷ˸˸̹̹˸˸ʷʷɶȵɶ˸̹ɶǴ̷̷̷̷̷̷̷̷ͶͶηηηηͶͶйϸϸηηϸϸйηηηϸϸϸϸййϸηηηηϸйϸϸϸϸϸйййηηηϸϸϸϸϸϸϸϸϸййййѺѺѺйййййϸϸϸйѺѺһһййййййййййѺѺѺѺййййййййййһѺѺййѺѺһ˸˸̹̹̹̹˸˸̹ʷȵȵɶ˸ʷɶ̷̷̷̷̷̷̷̷ͶηηϸϸηηͶйϸϸϸϸϸϸйηηϸϸϸϸйййϸϸϸϸϸϸйϸϸϸϸййййϸϸϸϸϸйййϸϸййййѺѺѺѺѺѺѺййййййѺѺһһӼѺѺѺѺѺѺѺѺйѺѺһһѺѺйѺѺѺѺѺѺѺѺһһѺѺѺѺһһ̹̹̹̹̹̹̹̹ͺ˸ȵǴȵʷ˸̷̷̷̷̷̷̷̷̹ηϸϸййϸϸηιι͸͸͸͸ιι͸͸͸͸ιιιι͸͸ιιιι͸͸͸͸͸ιιιιϺ͸͸ιιιιϺϺιιιϺϺϺϺϺһһһһѺѺѺѺѺѺѺһһӼӼӼһһһһһһһһѺѺһһһһѺѺһһһһһһһһһһѺѺѺѺһһ̹ͺͺͺͺͺͺ̹̹˸ɶɶɶʷ˸̹͸͸͸͸͸͸͸͸ϸϸййййϸϸιιιιιιιι͸͸ιιιιϺϺ͸͸ιϺϺι͸͸ιιιιιϺϺϺιιιϺϺϺϺлϺϺϺϺллллӼӼӼһһһһһѺѺһһһӼӼӼһһһһһһһһһһһһһһһһһһһһһһһһӼһһһһһһӼϺϺϺϺϺϺϺϺ̷͸ιι͸͸͸͸͸͸͸͸͸͸͸͸ιιѺѺѺѺййιιϺϺϺϺιιιιιιϺϺϺϺ͸ιϺллϺι͸ιιιϺϺϺϺлϺϺϺϺллллϺллллѼѼѼԽӼӼӼӼһһһһһһһһһӼӼӼӼӼӼӼӼӼӼӼһһһһһһӼһһһһһһһһӼӼһһһһӼӼϺϺϺιιϺϺϺ˶͸ϺϺι͸͸͸ιιιιιιιιιιѺѺѺѺййϺϺϺϺϺϺϺϺιιϺϺϺϺллϺϺϺллϺϺϺϺϺϺϺллллϺϺϺϺлллллллллѼѼѼԽԽԽӼӼӼӼһһһһһһһӼӼӼӼӼӼӼӼӼӼӼӼӼӼӼӼӼӼһһһһһһһһԽԽӼӼӼӼԽԽ͹͹̸̸̸̸͹͹˷̸͹͹˷ʶ̸λ̹̹̹̹ιιιιιιϺϺѹѹииϺϺллллϺϺϺϺϺϺллллллϺϺϺϺллϺϺϺлллллϺϺϺϺлллллллллѼѼѼԽԽӼӼӼӼӼһӼӼӼӼӼӼӼӼӼӼӼӼӼӼӼӼԽԽӼӼӼӼԽԽӼӼӼӼӼӼӼӼԽԽӼӼӼӼԽԽ͹͹̸̸̸̸͹͹͹͹͹˷ɵɵ͹мͺͺͺͺϺϺϺϺιιϺϺѹѹииϺϺллллϺϺϺϺϺлллллѼлϺιιϺлѼϺϺллллѼѼϺϺϺϺлллллллллѼѼѼԽԽӼӼӼӼһһԽԽԽԽԽԽԽԽӼӼӼӼӼӼӼӼԽԽӼӼӼӼԽԽԽԽԽԽԽԽԽԽվԽԽӼӼԽԽվѺѺйѺѺһӼԽйѺһһһһһһӼһһһһӼԽԽһӼӼԽԽӼӼһһһһӼӼӼӼԽӼӼӼӼӼӼӼӼһӼվվԽԽվֿ¬ֿֿ¬ֿԽԽվֿֿսӼ׿¬ֿֿֿֿֿֿֿֿֿ׿׿׿׿׿׿׿׿ԽӼһѺѺѺѺѺѺһӼӼԽӼӼӼӼһһһһӼԽԽӼӼӼԽԽӼӼӼӼӼӼԽԽԽԽվԽԽԽԽԽԽԽԽӼԽվվԽԽվվվֿֿֿֿֿֿվվíֿֿֿֿֿֿֿԽԽӼһѺѺѺѺӼӼԽԽվվԽԽӼӼӼӼӼӼԽԽӼӼԽԽԽԽӼӼԽԽվվվվֿֿվվվվվվվվԽֿֿֿվվֿվվֿֿֿ¬¬¬¬¬¬¬¬¬¬¬ֿֿ¬íֿֿֿֿ¬íí¬¬¬¬¬¬¬¬һһһһһӼԽվӼԽԽվվվվվӼӼӼӼԽԽԽվӼԽԽվվԽԽӼվվվվֿֿֿֿվվվվվվվվֿֿվֿ¬¬í¬¬¬¬íí¬¬¬¬íí¬¬¬¬¬¬í¬¬í¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬һһһһӼԽվվӼԽԽվվվվվӼԽԽԽվվվվԽԽվվվվԽԽ־־־־׿׿׿׿׿׿׿׿׿׿׿׿ֿֿֿ¬¬íííí¬¬ííííí¬¬íííí¬¬í¬ֿ¬ֿ¬¬¬¬¬¬¬¬¬¬¬¬¬ííííííííֿվԽӼӼӼӼӼӼԽԽվվվվվԽԽվվվվվվվվվֿֿվվվ־־־־׿׿׿׿׿׿׿׿׿׿׿׿ֿֿ¬¬¬¬¬íĮííí¬ííĮĮíí¬ůíֿֿ¬íֿ¬í¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬ííííííííֿվվԽӼӼӼӼԽԽվվֿֿվվԽԽվֿֿֿֿվվվֿֿֿֿվվ־־׿׿׿׿׿׿׿׿׿׿׿׿վ¬¬¬¬¬¬¬íĮĮĮíí¬íííííí¬Įí¬¬íííĮí¬¬¬¬íí¬¬¬¬¬¬íí¬¬¬¬¬¬¬¬ĮĮĮĮĮĮĮĮԽӼӼӼԽվֿֿԽԽվֿֿֿֿվԽվվֿֿֿֿվվվֿֿֿֿվվ׿׿׿׿׿׿׿׿׿׿׿׿վֿ¬¬ííĮĮĮĮĮííĮĮĮĮíí¬¬íííí¬¬ííĮĮĮí¬Į¬¬Įůí¬¬¬¬ííí¬ííĮůů¬¬¬¬¬¬¬¬ĮĮĮĮĮĮĮĮ¬í¬ֿֿֿ¬íĮĮ¬ŬêֿíĮƲïԿҽҼӽԾӿͽʻɹȹȹȹǷǷȸƹȸȸȸȸȸǷȸȸɸɸɸ˸˸͸ϺһһӼӼԻԺӺӹѺӹһӼԽԽӾӾҽѼѼлллλʹɸȸɹ˻̼ʻǺƸŹǻǼƺú¶µ¶ŶƷǸʺʺ˹ʹ˸˸Ϻмκ˴ưí¬¬¬¬íí¬Ŭī©íĮİԾҼҼӽԽҾϿ;˼˼ʻʻȸǷǷǷƶƶǷǷȸɹ˻˻ʺʺ̹̹ϺϺһһջջջջպԺջӼһһһһϺϺѼѼллллѼϼλ˺ɹʺ˻̼ɺȹǺǹƺƺŹĸ÷¶ȹɺʻ˽ξϿϼнҾҾӽкͷʴֿ¬í¬¬íĮĮ¬¬íí¬īīīê¬¬íí­ӽӽӽӽӽмоξξξξͽ̼ʺʺʺʺʺʹ˺ͼͼͽ̼˻ʺ̹ͺлѼӼӼֻּּּּջջӼӼӼӼһллϺϺϺϺлѼҽннͽʺ˻̼̼ɺǸǺǺŹŹŹĸø÷÷÷¶÷ŹŹĸ÷ĸ¶ĸƻ̽ϿϿѿò²ӽкѹҺíĮííĮůůí¬íííīīīīíí¬¬ԿԿӽԾԾԾҼκͻ̼ͽϿϿϿξͽ̼ͽξξνννͽξͽ˻ʺ̹ͺѼҽվվ׽׽׽׽ؽ׽ӼӼԽվվֿллϺϺллѼннͽ˻̼ͽͽʻɺʺȻǹĸĸĸŹĹŹøķĹƺƺŹĸĸ·´Ķƻ˾Ѿо±ĳóԾҼս־¬íůůííííůí¬íííííííí¬ӾӾԿտӽϻνϾппоϽμμμо±Ѿλ̹ҿѿϽμμϽӿֿֿֿֿؿؿؿؿԽվվֿ²ӿҾҾѽѽѽѽϽнͽͽξξϿϿ̾˼ɽȻǺǺǹȺƺǹŹƷŹȺȺƸŸƹŹǷǻ̼µóµ³³°׿׿íůưůí¬¬íĮí¬¬íĮííííííí¬ԿԿ°տӽ¯¯Ͻμͻͻѿòĳôнμ±±ӿҾҾҾоѾξξϿξ̽̽ʽʽɼɼɼɼȻɹȻ˻ɽʻȹʻ˽ν¶÷÷µҿ³ŴŶƵƵƴñ°®®íĮůůĮíííĮí¬íĮĮí¬ůůĮí¬¬­įį­įįîӿҾӿ°ñĲĲŴĳòò±ññññññ°ññ°°°°ññĲĲññññ°°°°ð²óϿο;̽̽˼ͼ;пϿ·öķķķŵ±ñŴƴǶǵƴƴųİïİİůůĮíůůĮííĮíííĮůůíǱưĮí¬¬®®­îįŰį­îîî­ñƴȶ°°±ĳŴǵ°ñĲĲñ°Ĳññ°°ññĲññĲĲųƴǵǵ°°°°°ñĲĲĳ±²óó²µ÷÷¶пξξξϿöķķĴöŵŸƶôĳŶǶɷɷʸʸɷǵƴŰǳǳǳǳǱưůůưȳͷӾ°įî¬®¬׿־¬¬¬ííí¬¬¬¬׿վ¬¬ííĮíĮůůĮíĮůǱůí¬íĮůưůůůĮ¬¬¬¬¬¬ĮůĮí¬¬íĮĮůůůĮ¬¬¬¬¬íííí¬¬íí¬¬¬ííĮůůůůůĮĮĮĮĮ¬¬íííĮĮĮ̴ζҺ׿®ï®¬ĮĮí¬¬¬¬íííí¬ííííí¬¬¬ííĮĮůĮůůůĮíĮůưůííĮĮůůíĮůĮí¬¬íĮí¬íĮĮí¬íĮĮííĮůůůůůĮí¬¬¬¬¬¬¬ííí¬¬í¬¬¬¬¬íĮĮůůůůůĮĮĮĮí¬¬íííĮĮĮѹԼ׿®ïï®®Įí¬íĮưưůííííííĮĮíĮĮůůůůůííĮĮůůůưĮůưůĮĮůưůůĮĮůůůů¬ĮůĮííĮůůĮĮĮůưůí¬ĮĮĮĮůưưůĮííííí¬¬¬¬íí¬ííííí¬íííĮĮůůůĮĮĮĮĮíí¬¬ííĮĮĮĮսïİİİİİưůííůưǱưůĮĮĮĮĮůůůůưưưưůůĮĮůůůưưưĮưưưůĮůưůůůưưưůĮĮůůůĮíĮůůĮĮĮůưĮííůůĮĮůưưůĮí¬¬íĮ¬¬¬¬íí¬ííĮíííííĮĮĮůůůůĮĮĮĮíííííííĮĮĮů®İűűűƲǳɳǱůĮůưưůưưůůůůưưưưưưưůĮíůůůůưưưưůưǱưůůưǱưưưưǱǱưůưǱǱưĮííĮůĮĮůưưĮíĮůưưĮĮĮůưůĮí¬¬íĮ¬¬¬¬¬ííííĮĮĮĮí¬¬ĮĮĮůůůůůůůůĮĮĮĮííííĮĮĮůů®ïűűƲƲǳȴɳǱưůưưůĮȲǱưưůưưǱǱǱǱǱưůĮíưưưưưưưưưǱǱǱưůưǱǱưưưǱǱǱưǱȲȲưĮííĮưůůưǱǱưĮůưǱưůĮĮůưůĮííííí¬¬¬ííííĮůůůůĮí¬¬ůůůůůůůůůůůůůĮĮĮííĮĮĮůůůƲűİűűƲƲƲȲǱưǱȲȲǱůɳȲǱưưưǱȲǱǱȲȲǱǱưůưưưưưưưưưǱȲǱưưǱȲȲǱưůưǱǱȲưǱǱǱůĮĮůưưưǱȲȲưĮĮůǱǱưůưǱůůůůĮí¬¬ííííĮĮĮĮĮĮůůůĮĮíưưưưưưưưưưưůůůůůííĮĮůůůůȴƲİİűƲűİưưưȲʴʴȲǱʴɳȲǱưǱǱȲǱǱȲɳɳɳȲȲǱǱǱǱǱǱǱǱưǱȲȲưưǱȲɳȲưůůǱȲɳůưǱưůůưǱưůưǱȲȲưĮíĮưưưưǱȲĮĮůůůí¬íííĮĮĮĮĮííĮůůůůůưưưưưưưưưưưưưůůůíĮĮĮůůůůīīĬĬĬĬëëªëëĬĬĬëëªªªëëĬĬĬëëĬůůĮĮí©ªīĬƭƮǮĬŬĬīëŬĬĮĮïïïïïïï®ïİİİï®ƴĲ°°ñññ°°­­°įñî°îսïİ׿־¬¬¬¬¬¬¬¬ưůí¬ĮůëëëëëëëëëëĬĬĬëëëĬĬëëëëëëëëĬŭŭŭŭĬīīīīŬŬŬŬƭŬŬīīŬŬƭĮïïïïïïïïïİűİï®ñ°°ñññ°°°°°°°°°°î®ï®׿ííííííííííí¬¬¬¬¬ëëëëëëëëĬĬĬĬĬëëëŭŭŭĬëëëªëëĬŭŭŭŭŭƭŬŬŬīīīêƭŬŬīīŬŬƭĮĮĮĮĮĮĮĮĮůưưưůĮí­­­­­­­îîîîîîîîî®ïïï®®®®ïïï¬¬¬¬¬¬¬ĮĮĮ¬¬Įíííííííí¬ííĮííŭĬĬëëĬĬŭƮŭŭĬĬëĬĬŭŭŭĬĬĬĬëĬĬŭŭŭĬëëƭŬŬŬŬīīīƭƭŬŬŬŬƭƭĮĮĮĮĮĮĮĮůůưưưůĮí­­î­­­­­­­­­­׿®İİï®İİİïï®®®ííííííííĮĮĮí¬¬ííííí¬¬ííííííííí¬¬ƮŭŭĬĬŭŭƮǯƮŭĬĬĬĬŭŬŬŬƭƭƭƭǮƭƭƭƭŬīê©īŬŬŬŬƭƭƭƭƭŬŬŬŬƭƭůůůůůůůůůůưưůůĮĮĮĮĮíí¬¬¬¬¬¬¬¬íĮĮĮ¬ůĮĮĮíí¬¬íííííííí¬íĮůůĮ¬íí¬¬¬¬ííůĮ¬¬íƮƮƮƮƮƮƮƮǯƮŭĬĬĬŭƮŬŬŬƭǮǮȯȯǮǮǮƭŬīêêīŬŬƭƭǮȯȯǮƭƭŬŬƭƭǮůůůůůůůůůůůůůĮĮĮưůĮí¬¬¬¬¬¬¬¬¬¬ííí¬¬¬¬ííííííííííí¬íĮůưů¬ֿíí¬¬ííůíֿֿ¬íưưưưưưưưȲưůĮĮůưǱůůưưưưưưĮůůưưưůůůůůưưǱǱǱưůůĮĮůůưůůůůůůůůůůůůĮĮĮĮŭĬëªªªëëĬĬëëëªªªªªªªëëëëªªëëëīīīīīīīīƭŬīŬǮǮī©Įí¬¬íĮĮí¬¬íůůưưưưůůȲưůĮĮůǱȲǱǱǱưưůůůíĮůưǱȲȲȲưưưưưưưǱưůůůůůůưůůůůůůůůůůĮĮĮĮííëªëĬƮŭŭĬĬëëªªëëªªëëĬĬĬĬĬëëªªªīīīīīīīīɰƭīīƭǮƭīĮĮí¬¬íĮĮĮĮůůůĮí¬¬¬¬¬¬¬¬¬íĮůůí¬¬íí¬¬׿׿׿ïï®׿׿׿־־־־־־־־սĲĲ־°ԿԿԿԿԿԿԿԿԿֿ־־ս־־׿׿־־ս׿׿׿־־սսս־־־־սսսսííííí¬¬¬¬¬íĮí¬¬¬íí¬¬¬¬¬׿־ï׿׿׿ս°־Լ־ԿԿԿԿԿԿԿԿֿֿֿ־־ս־־׿׿־־ս־־־־־־־־־־־־־սսսĮĮĮííí¬¬ííííí¬¬¬¬¬íí¬¬¬¬¬¬¬¬¬¬íííí¬ֿí¬վֿ¬íí־׿սԼսԿԿԿԿԿԿԿֿֿֿվվ־־׿׿׿׿־־սսս־־׿׿׿׿־־־־־սĮĮĮíí¬¬¬ůĮĮííííí¬¬íí¬¬íí¬¬¬¬¬¬¬¬¬íֿ¬¬׿׿׿׿®׿սս׿­ֿֿվվ־׿׿׿׿־־־־־׿׿׿׿׿׿׿׿־־־־Įííí¬¬ĮĮí¬¬¬¬í¬¬íí¬¬¬¬¬¬¬ֿ¬¬í¬¬ֿĮí׿׿­­ֿվ׿׿׿׿׿׿׿׿־־־־׿׿׿׿־ííí¬¬¬¬¬¬¬¬¬¬íí¬¬¬¬¬¬¬¬¬ֿֿí¬Įíֿֿֿ¬¬¬¬¬¬¬¬í¬­­­­­­­­î­­ֿ׿׿׿׿־־ս׿׿׿íííí¬¬¬¬¬¬ííí¬¬¬íí¬¬¬¬¬¬¬ííí©©êêê©Ŭê©ê©©©©©©©©©êê©©©©©©êêêêêê¬¬¬¬¬¬¬­­îî­­îî­­­¬¬¬¬׿׿׿׿׿׿׿׿׿׿íííííííí¬íůưůĮ¬¬¬íí¬¬¬¬ííííĮĮīīīīêտŬê©©©ê©©©©©©©©©©êīīīê©¬¬¬íĮĮ¬­­­­îî­­­­¬¬íí¬¬־־־׿׿ֽֽֽֽֽֽֽֽ׾׾׾ֽֽֽֽֽһӼվֿֿվӼһѺѺһӼӼԽվվӼӼԽԽԽԽӼӼվվվվվվվվһӼԽԽվվվվվվԽԽԽӼӽӽֿվվԽԽԽԽԽӼӼӼӼӼӼӼӼӻӻӻӻӻԼԼԼԼԼӻӻӻӻӻҺԼӻӻӻӻҺҺҺԼԼԼսսսսսԼӻӻӻԼԼҺѹҺҺҺҺӻӻӻӻֽֽֽֽֽֽֽֽ׾׾׾׾ֽֽֽֽԽԽԽԽԽԽԽԽӼӼӼӼӼӼӼӻӽӼԽԽԽԽӼӼԽԽԽԽԽԽԽԽԽԽվվվվԽԽվԽԽԽԽӼӽӽֿվԽԽӼԽԽԽӼӼӼӼӼӼӼӼӻӻӻӻԼԼԼԼӻӻӻӻӻҺҺҺԼԼӻӻӻӻҺҺԼԼԼսսսսսսԼӻԼսսӻѹҺҺҺҺӻӻӻӻ׽׽׽׽׽׽׽׽׽׽׽׽ּּּּսսԼӻӻԼսսԼԼԼԼӻӻӻӻӽӽԾԾԾԾӽӽӽӽӽӽӽӽӽӽֿֿֿֿվԽԽӼվԽԽԽԽԽԽӼվվԽӼӼӼӼԽӼӼӼӼӼӼӼӼӻӻӻӻԼԼԼԼӻӻӻӻӻҺҺҺԼԼԼԼӻӻӻӻԼԼԼսսսսսսԼԼԼսսӻҺҺҺҺӻӻӻӻӻ׽׽׽׽׽׽׽׽ؾ׽׽׽׽ּּּսսԼԼԼԼսսԼԼԼԼԼԼԼԼӽӽԾԾԾԾӽӽӽӽӽӽӽӽӽӽվվվվվԽԽԽԽԽԽԽԽԽԽԽվԽԽӼӼӼӼӼӼӼӼӼӼӼӼӼӻӻӻԼԼԼԼսԼԼԼԼӻӻӻӻսսԼԼԼԼӻӻԼԼԼսսսսսսԼӻԼսսӻҺӻӻӻӻӻӻӻӻؾؾؾؾؾؾؾؾؾؾؾ׽׽׽׽ּӻԼս־־սԼӻӻӻԼԼսս־־ӽӽԾԾԾԾӽӽӽӽӽӽӽӽӽӽӽӽԾԾԾԾվվԽԽԼԼսսսսվԽԽӼӼӼӼӼԽԽԽԽԽԽԽԽӻԼԼԼԼսսսսսսսԼԼԼԼԽԽԽԽӼӼӼӼӼӼӼԽԽԽԽԽӼһһһӼӼһйһһһһһһһһؾؾؾؾؾؾؾؾؾؾؾؾ׽׽׽׽ӻԼ־׿׿־ԼӻӻӻԼսս־׿׿ӽӽԾԾԾԾӽӽӽӽӽӽӽӽӽӽӽӽӽӽԾտվֿԽԽԼսսսսսվվԽӼӼӼӼԽԽԽԽԽԽԽԽԽԼԼԼԼսսսս־־־սսսսսվվԽԽԽԽӼӼӼӼӼԽԽԽԽԽӼһһһӼӼѺйӼӼӼӼһһһһ׿׿׿׿׿׿׿׿־־־־սսսսԼս־־־־սԼԼսսս־־־־ӾӾԿԿԿԿӾӾԿԿԿԿԿԿԿԿԿԿԿԾԾվվԽԽսսսս־־ֿվԽԽӼԽԽԽԽԽԽԽԽԽԽԽԼԼԼԼսսսս־־־սսսսսվվվվԽԽԽԽӼӼӼԽԽԽԽԽӼӼһӼӼӼһйԽӼӼӼӼһһһ׿׿׿׿׿׿׿׿־־־־־սսս־־սԼԼս־־־־־־־սսսӾӾԿԿԿԿӾӾ§ԿԾԾԽԽԽԽսսս־־־־վվԽԽԽԽԽԽԽԽԽԽԽԽԽԼԼԼսսսսս־־սսսսԼԼվվվվվԽԽԽӼӼӼԽԽԽԽԽԽӼӼӼԽԽһѺԽԽӼӼӼһһһҺѹѹѹѹҺӻӻѹѹѹѹѹҺҺҺҺҺѹѹѹѹҺҺииииииииϷѹҺѹϷ͵ϷѹииииииииҺҺҺҺѹϷζ͵ϷϷϷϷϷϷϷϷийϸϸϸϸϸηййййййййϸйѺйηηηϸϸϸϸϸϸϸϸϸѸзжзжзж϶ѷѸѷѸжзжζζζζζ͵͵͵͵ϷϷϷζζ͵͵͵ҺҺѹѹҺҺӻӻӻӻҺҺҺѹѹѹӻҺҺѹѹҺҺӻѹѹѹѹѹѹѹѹиѹҺѹϷζϷѹииииииииϷϷиѹҺҺҺҺиииииииииййϸϸϸϸηййййййййϸйѺйηηηϸϸϸϸϸϸϸϸϸжжжжжѷѷѷжжжѷѷѷѷѷϷϷϷϷζζζζ͵͵͵͵ζζζζҺҺҺҺҺӻӻӻսԼԼӻҺѹѹиӻӻҺҺҺҺӻӻҺҺҺҺҺҺҺҺѹҺӻҺиииѹииииииииζϷиҺӻԼԼԼѹѹѹѹѹѹѹѹиииϷϷϷϷϷϷϷϷϷϷϷϷϷϷиѹиϷζϷиϷϷϷϷϷϷϷϷϵжжжѷѷҸҸжжжѷѷҸҸҸиииииϷϷϷ͵͵͵ζϷϷииҺҺӻӻӻӻӻӻսսԼԼӻҺҺҺӻӻӻҺҺӻӻӻӻӻӻӻӻӻӻӻҺҺӻҺѹѹѹѹѹѹѹѹѹѹѹѹҺҺҺӻҺҺѹѹѹѹѹѹѹѹѹѹииииϷϷϷϷϷϷϷϷϷϷϷϷϷиѹиϷζϷиииииииииѷѷѷѷѷѷѷѷϵжжѷҸӹӹԺѹѹѹиииииϷϷиииѹѹѹҺҺӻԼԼԼԼӻԼԼԼԼԼԼԼԼԼԼӻӻӻӻԼԼӻӻӻӻӻӻӻӻӻӻҺҺҺҺҺѹҺҺҺҺҺҺҺҺӻӻӻӻҺиϷϷҺҺҺҺҺҺҺҺѹииииϷϷϷϷϷϷϷϷϷϷϷиѹѹѹϷζϷиииииииииѹѹѹиϷϷζζζζϷииѹҺҺѹѹѹиииииѹѹѹѹииииҺӻԼսսսԼӻӻӻԼԼԼսսսսԼԼӻӻԼԼսӻӻӻӻӻӻӻӻԼӻҺҺӻӻҺѹҺҺҺҺҺҺҺҺѹѹҺҺҺҺѹѹҺҺҺҺҺҺҺҺѹѹѹииииϷиииииииииѹҺѹϷϷϷиииииииииҺҺѹѹиϷϷζϷϷииѹѹҺҺѹѹѹиииииѹѹѹииϷϷζҺӻս־־սԼӻսԼԼԼԼԼԼԼսսԼԼԼԼսսӻӻӻӻӻӻӻӻսӻѹҺӻԼҺѹҺҺҺҺҺҺҺҺиѹҺӻӻӻӻӻҺҺҺҺҺҺҺҺѹѹѹиииииѹѹѹѹѹѹѹѹиѹҺѹиϷиѹииииииииййййййййййййййййѹѹѹѹииииииииииииҺӻս־׿־Լӻ־־սԼԼӻҺҺսսԼԼԼԼսսԼԼԼԼԼԼԼԼսӻѹҺӻԼҺиӻӻӻӻӻӻӻӻҺӻӻӻӻӻҺҺҺҺҺҺҺҺҺҺѹѹѹѹииииѹѹѹѹѹѹѹѹиѹҺѹиϷиѹииииииииηηϸϸйѺѺһѺѺѺййййϸҺҺѹѹѹѹиииииѹѹѹҺҺ~}~~~|~}||{{||~|{|~{~|{{{{yxx|}zy|{vzyyyyyyxwx{|||{zxyz{{zyx{{zxxwwx}~~~}~}{}|{{||{zy|}zz}}z~~}||{{z||~~}}||{{zzzz~}}|||}}~|}|||~~}|~}||~~~~}|{{|}{{z{{{||~~~}~}}}}}{{{~~zzzyyyyyz{zxxyxwvvwxxwutvuttuutsrrtvxwvuuuuvyxusvuuuuuvwtssuvvvxxusrttrpwvututttstuuutsrqqrrrrssuttstttuuttuwwvtrsuvvusrtssvxyyxyyzzzzz{wxyxxzzy{zyxxwwwwvvwyywvuuuuwwwwwwwvxxyxwwvvwwxxwvvxxwwx{xvuwxxwwwvvxyzxsstvvwwwttttttttuttsuvvvvvuvxxwuuuvwvvutzxvutssoxyyyzz{{xyzyyzzyzywvvvxywvvwyxvszywvuuvwxyyxwx{~ywvvvwxxyxxyywwxzxuuxz{{wwwwwxxytrrrstuvttttttttttssvvvwvuuuxxwvwwwvvvuuutstuuus||||||||}~~|{{zxwwvvwxyz|zxwxxvtyxxwvwwwzzzzyz{}xxwwwxxy{zz||zz{zyxxz{{zzyxwvvvvvutssstuxxxxwwwwxwwwwyyyywvwwzxuxwvuwuwusqssxwzy~~}}||{{|}}{zzywwxxyyxww}zwvvwxyuuvwyyyxzzyz}|zyywvvvvvwxxy{|{z{|}~}|zy{{yxwwwwzyxwvwxx||||{{{{zzzyxyxxywvvwyxwyvvuvtvtzwwtvssq~~~}~~|yxzyyxxz}wxy{}}|{}||}|w}zyyxxxxxxy|}|{|~~|{{yyyyyzz{xxxxyz{|||||{{{{}}||{z{z|zxxyyzywwwwwvvv{ywvutrp~{}}|~~~~~~~~}|{{{zy{}}|{||}}|{{|~zy{{{||}wxyz{{{|{{{{{{{{zz}}||{{|{{z{{zyxxyzwwvuvuuvxxxw~~~|{|~~{zz}}|yyz~~~||}~}|{z}{}{||||xy|}}}}{~|{zzzzyxyz|zxwvzyyy{{{zututrqrsprtspnoponopppppnmllnnmnoonmmmnnupklmmmmklllmnoopoqpoonnsronnprtrommopnlopponmmnmmnoqqomlllmmmmnnmllmmlkmljjkklkmihjlkjirsssssstrtuurqqrrrrrqponppponmmmnmolnmomoknptpolrprpqonmkkkkmkmmooqnpmomsoomqpqpnprpnmnpqpppqpmkonnmlkkkkkjknonnmkjkllljoljlnmkktsrrsrrqqrtsrqqrtqqqponmrssqnmmnnnomonoonloqspomqpqpomkjpppqsqstlmqqsooltpqoqpqpmoqpmlnppoooonljnnmmlkjjkjjkmnnmkkkkllljpmlmnlkkwvtstsqprsstssrponpnqqqqqrrppooopppppqqqtronmmnpoonnnnnnmmmmmmmmjkppspqntqropmnmmqrqpopqonnoqqpnooooopppponnoonmmmmoponlomlmmlklvussttsrtttuuutspnpnpqqqqpooqrqpqqqrrrrrurponmoqqponnpstppoonnmmmmonononqpqoomnnrqpprrqponnopqpoooooppppponnoonmllmnonnkmllmmkkmuuuvwxyxxwwwxxwsuutsrqsstrqrtuvtuuvvvvvvsstwxvtsxvtrrsuvxwyxwvvuvusqpoppmoqqqprstsqruvtqutrrsrposrrqpoonnmmnprqqnnnopoomooopomnqvwwxwxxyyxwxyywuyvutuuuuvvvvwwyyxxyyyxxwvtuy{yvuwwwvuuttttsssrrrwvutssssoqssrqruvvtuwwusxwvuvutsttsrrqpppooprssrponnqqpoooqqqopsyz|xxtvu~zyy{{xvvtuuuvwwz{|{zyz{{y|z|yzxxvtxvwutvxzywusvvwwywyyrstuvwwxvxywtqstwvuuuutsxuvuywyvsqtrtrustqrpsqrosrppsssrpqrrqnpsnlkklljiklmljiknkiiknonlkmmllnmkijlmmljinmkijmnmllllmnopkg~g|joplg|mhghllkg~hknmigilhikkkklnllkklkjhmkjlmlknmmllllji~migilljgnlklnonnlllmnnnnmnnmkklospmlmnmliklkklljklmmmmlkmmlkmnnlmnnnnnnnnkijponijhghjkkhkmonljkmlmnmlllmiijklllknkklnmllmmmmmmlkkjjkllkjnmlmpqpollmmmnoomnnmlkmnsqnllllkjklllmmknnnnnnnnnooopqolppqqqponqomlonolmkjjkllkklmmnmmmoppomllmjjkllmmmmjlmnnmmlllloomljlmmlllmponopqponoqonlmmonomnmoonmoopoomnnpoppppoppooppqqqqqrsroqrsutsrqtqpoooppnnnmmmopmmmmponmopponmmnnoonmlllnlmoponnmmmnpponjmoolkmoqppooonmmnpmnkmlomnlonqomlporpqopnqprpqqrrqqqqrrsrqpqssqqsuvutsrssrpopqrooonllnpomnnppnlopqpoopqpqrqnmnpomlnqpppoooorrqplorqomoqopppoopplmnnnnoppnmnopppqrrqppqrrqrssqqqstttttttttrpqttsrsuvuuuustsrqqrspqrqooprqppqrrpnpqrrrrstoqsrppruqnnorrqqppppsrqpnopqpooplnpqqrtuooopqqqqsqopqrrpsttsppqssrrssqpqrsttttsrqqqpqsrorrssttssrsstrqqqpqrrsrrsqqpqssqoqrssrrstortsppsvroopssrrqqqqssqprqqrssrqoqqqpqsutsrrrrqpvsqqssrporuurqqqqooqpmlmoprssrponpqqsspmtssrrrqrrstuustqnpqrsqqqqpppqppoorsrqpqrrtvspnqtrpoqtsrrrrqqssqptrpruusprtsqnmnorrpoonoorrttsrppvspquvuruutsstuvvswy{vvuxvvvyzywuxzxtqsvwwz|}}zz{~utrrpqrrrqsrrrsssqnorssptsrqpqrpsrrttrrttqqrstsroquspnprrruwxyzy|zzy|}vvttrsturqqpqrtvtrpqssrotsponooptqpooorsrponqrqpopponnnnppqrrsttxvuuutwxyttrrqrstqqrqqrssusrrstrqrrooopqqqqqpoprrsrqprrrrrqppqqpossstttuuopqsrttuv{|ssqqrsrsrrssrqrqutttrrrqppnopqrsmnonppolrrtrrqrrrpoprsqpvvvvvvvvrstvuvttt{{}ttrrssrsrsttsqqorsssqqqqqqpqrstsmprprsqmrsutrrstrqpqstsrvvvvvvvvwwwxvusrvzz|wvvvtuttssstutsssttuttstuusttuutorspruuprsvusrvvsrrsuvvuvvvvvvvvwwuvtrsst{{~vuuuustttssrssvwsuvvvvwvussqsqsqprsnotuqprutqqsurrrstuuuwwwwwwwwsqrrttvwsxz}ǽɿɿɿɿɿɿɿɿɿƿƿƿƿžƿƿƿƿƿžžžžƿƿƿƿƿƿƿƿƿƿƿƿƿžžžžžžžžƿƿĽĽĽĽĽĽĽĽſſľľýýľľľľľľýýýýɿɿȾƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿƿžžžžžžžžſľľľľľľľľľľýýýýĿĿƿžžžžƿƿƿžžžžĽĽƿƿžƿƿƿƿƿƿƿžžžžǿƿƿƿƿƿƿƿƿžžǿƿƿƿƿƿľžžžľľľľýýýýý¼¼úúúúú¹¹¹¹úúúúúúúú·øĹĹø·øĹĹĹĹøøøø·ĹĹøøøøĹĹøøøøø··öĸ÷¶¶÷ĸĸ¶÷ĸ¶¶¶¶¶¶ĽĽĽĽýýý¼ýý¼¼¼¼úúúúú¹¹¹ĻĻĻĻĻĻĻĻøĹźĹøøøź··øĹĹźƻƻźĹĹøøĹĹźĹĹĹøøøø·¶¶÷÷÷÷¶¶÷÷÷¶¶¶¶žžĽĽĽüüüýýý¼¼¼¼¼ĻĻúúúúú¹ĻĻĻĻĻĻĻĻ¹úĻĻ¹¹úĻ¹úúĻżżźźĹĹĹĹźźźźĹĹĹĹøø¶÷ĸĸ÷¶÷¶÷¶¶¶¶¶¶¶¶¶¶¶¶÷¶¶ƿƿƿžžĽĽĽſľľľľýýýĻĻĻĻúúúúúúúúúúúú¹úĻĻ¹¹úĻúúú¹¹¹¹¹źźĹĹĹĹźźźźźźźĹĹĹö¶÷ĸĸ÷¶¶÷¶¶¶÷÷¶¶÷÷÷÷÷÷÷÷¶¶¶¶¶÷÷¶¶¶¶¶¶¶¶¶¶¶¶ƿƿžžĽĽƿƿƿƿľľľľľľľýýýý¼ýýýýýýýý¹úĻĻ¹¹úĻúúúúú¹¹¹ĻĻúúúúĻĻżżżĻĻĻĻźŸŸķö¶÷ĸĸ÷ĸĸĸ÷÷÷ĸ÷÷÷÷÷÷÷÷¶¶¶¶¶¶¶÷÷÷÷÷¶¶¶¶¶¶¶¶¶¶¶÷÷÷ƿƿƿƿžžžĽƿžžžľľýýľľľľľýýýſſſſſſſſúĻżĻúúúĻ¹úúĻżƽƽǾĻĻúúúúĻĻżżżżĻĻĻźźŸķö¶÷ĸŹ÷ŹŹŹĸ÷ĸŹĸĸĸĸĸ÷÷÷÷¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶÷÷÷÷ĸ÷÷÷÷÷÷÷÷¶¶÷÷ĸĸĿĿĿĿĿſſľľľľýýýľſľýýľſ¼ýýľſżĻĻúúĻĻżżżżżĻĻĻźĹŸķķķķĸĸ÷ŹƺŹ÷÷ĸƺŹĸĸĸ÷÷÷÷÷÷÷¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶¶÷÷÷÷ĸ÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷ſſſľľľľľſſſſſſſſľſſľľſſľľľľýýýżżĻĻĻĻżżżżżżĻĻĻĻ·ķĹƹźŸø¶·ĸƻŹø¶ĹƺĺŹùĸ¸÷¶¸÷¸÷¶¶¸÷¸÷¸÷¸÷¶÷¸÷¸÷¸÷¸÷¸÷¸÷ùĸùĸ¸÷¶X || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var operationGroup = null;

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    if (operationGroup) {
      operationGroup.ops.push(cm.curOp);
    } else {
      cm.curOp.ownsGroup = operationGroup = {
        ops: [cm.curOp],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        callbacks[i].call(null);
      for (var j = 0; j < group.ops.length; j++) {
     ;[<_EX O(  P  ̅]阿HzKy h2$ B;  hwմO](E @ SL 8(X瓕tu/K   p04>̎vj#cҁ  @h@,}uZGaN!{"P  H~N3s`RU!  @X2ac,(re2?>p3dpt  @]@7`Cr
惘,o]ƔI  >l<Qw09Gb&  1vUu#޴.MwXNȓN  x$
(JH<]+tgbE2 I1	AMЍd3dH  bN0hv$Wm  	<O)y X#M99   ب;m,"uK'rj 5[Y  R?|t:fvEƳ9 	ԌJ +7  .ץ :8I	K춴eY  *!I0䤠 !'x)u 	R  !@϶'Gp+JSxP!  iTHwN_fSX`q  gCE!bt" Otp<an !  	:ؗ'֯"_{K|9'   YDڛ1c̃a  B r2,&5 ft$  @(VYH")G0:  ӸH:i`3ΖNK8:t 9&HO#7֛)P|7FE  ci?:RןlwphJKV B  R}x  %v;(o   B("oEm
oLli  B u>1 &>̗iFLVSn"  @Y
0/z;dL6C#"@  )9ʼ'	7BlXP  @l
&{ߊ< Q,ɉt`0@  @L0bio6pg#yLM   F9Gç5IucdL @ g2ӌu`G8}zARr   :(gz슪Z.ҥެˏ  B*8c-XIU!  &ZO*v]9lHM  |&3%zd;YMu !  ^M4-5a!zHpy   U#rl W5U@~;(k  l)=Jөnf@Z'  ١= ϶[I]QXtaw: s0u>Ҥ_t6C_SD]w:@!  8Z:ptEUoX/RyP}   ˘js#g}W9W`%Pf"   x&w4pcZ6
)7z-  	^euu(HAٷ?Si  	tD"gSt{  !.&&$aY7N9!  z1KVGK 'tŎ070'JB  Ѷ9U7Ԝq޹Sb<m !  5Z/&	M+zC7 @ 0cxUڔQ:)Gxt  A ў (("eVB%:iD  faQc33qlU{vJF  " )A.lI`Hm`0B   o9R]Þ К@~E@  A&#SeSr P4'݊[   .o^d#`r?`zC|  `l[nh{pM8Y7}Vx㓴әL  ,.n@k^FiE6D[F,g  !@-g9D9a̫kp!  ­AQ2=7`Q<v]  y	`I-{A.9SW !  S- 8ǆe{Cc˶܋  s+f:'kHz"Y@`  D >gXʧw+zU x0SH>  /  5Oă9ƋQE턅d3)TZ=  "?DZKە)2b!P',r   @5἞A'nV)Y06]iY@  ";2$&ޔ!@k뎼B֊'   @ugpt`P OZ0cEJ  L_3`Re>u>9  	!Fp[mZ9|{uj6p7  !9`-r)mtnOB   Hz:E ^P(2W 7%He9   >xv\x gfd3!s2< D  #14WEWzq@`uӣJP  RH_1SdTDcVo7@Q!|]  C)s9DС_[=  d+v6He{q¹   8H9JK>44[_ sYLbC;P w:  Lǔj 00JT  ~K3@6I7*R0  ! rQoPy9/,ʍdɬ*  Y` kNζ/^Tc"  !p9KClƫʨ%E=aޙX8M>B   KAxZZG:ƑjLJf9   ?XqSZS3'Av	 B  ״6@{8
->    wQV"oFЦ~pi   >ahT=؃֤ҌG2ē @Bຼ~JSK_{#   ! F?nF2.mr}   v((              W#(4ap*љ j!   (  m'r3ȯ"s k4  A}>uoF;QF0]b<f5ԑ !  Y;\[@U͝&qa}o  2BȕPu'A  ! 9GY>`ԗz4ϫj+	.  0WUp?hy˸hƋ|4 #TѽTkz.&	  ЌL_#m?Yjp!0pob  $2B]˃$;`FӀ  H2@aJp-8Vv	*  ~Bki&LKDGLanuQz0pl?  9{k*P,R#h   'tgKRG @ 
@&
Dtv o(s!  %Q!<hvef] ½hy pio୹Mcq0Ox  _F߂2M>C7@``n糍u  ?ݶx:fތΝOPA{j.EÉ  ҍ+3l`!gn ُfmT?  ^bp(ig(U@ e)(W*6y4YA$x?R  Ǌ%3ԆONn'.Q H
χ=}knk"EJ3  wDTTSo[P&X54.׶  _`vȇj#56	'd~4O6  ~D,te%ì!	m޽ux2  2|"% Qլ&WX  [7V=9[xPJ  kD=9zvk) w 4O rHH1	PA3Цz0 iz "  Po a0ϙ@h|$   jj+PH{>VZ`'g;+3aP   ]1`J|ԪdGj錬p9k  @p6O_$~nq˔^)n  N+uOF=7Pf:U`RV^  9VA˶p%-r/0> B  .ACzUqS?ͳَq+   :ʠGz(w >A|9cпȶ    1"Ӱ42SeuVoq  @$`W+ܭ4  ~Nh05r[ D   Qw[YrwKג9v0z1s@  ,ԩ촦GV1 ^9TT   blD:E0XT8V @ jR7fY}@Cv|Sbr|4{)&^   *PZ"(;:Hq6 *`\@bF(pɒpvp  RC 9Qh` 0  []2lsK/@59AE9eiR !  0b7 %~޷|<W:/q?o   ]RXޗ-PUѦ&u  D YFxfەp9$`ӫ>3  @4!9=Ol$PMM
İ$W6  ]C-0c}qNB  @\kh
Y "uEQ4_. gXL{   j\NVYy_lV	ۍqG B  )E A>i{   N6}p/{0+	d㳔DXic  B .ӇK@ǷM_?Dl'q2  @PQ0ZcJUGl(`  ۆC8)Q{{sh3gdWp2~ Y%E}UdzMDςuӥzu  WMJuOj4M[]  0*씒pJ|8KYnC  ! 0I5ALZw _0ʓ~   a!?wYy<&'O⹗b  BcP9@aioA_,)c,]ozP\KID   Ô7
Ke Jׇ<	=;z0   	B)[HbH8")F e"9ՅM B  |O[aM Y =:&p֎g @  efN J*n1݁fR$   ٵ0nUK
rk+C@QOz  @	@~YpIfq}Tx-2n/P  2P)ޘu\/p`o0 ZTeāzM5NAÚ78;pSx !  ZY-XJ#rQx  7hKǞb%C"	+r  " X<`j'F$yUC&n   qTU`9t7L9Wr}4  D	:Ad^l"|j&;2.S9IՄ  @9'wB@~QC|   `LeORQM%Mo<W5zz+   ̙ͽ: d3WOL"ɿ  " bB~H``;0t57w=b   Q* v/9bm=&e+$  D0.Jt> >tǙQF½@  @9l͟å@PX0b9+@  Ĥ؜͊!(`7hkI-   \
y&i-ph%hy^L  rfzW1[sbz9B-n*+=bBX  ҳU܂#@,)+% '\iαd~U0:@  q#J	J#HKm]8 |^>:^ZݘP.q:<:$6_d "  ϢC	Ѯp`3CVVKvH   .jsoN"-&"Wx    ΂   gt{ZW {}   ۩<k(  uT| ܦ          2](  ݍ2-N
0   ӿ+o.Kd)_@  V@O
nJGt,Pv d%1QPhrK4I/`k][  2ejQ1%^uH҉p<hf6.  -_(ZPP-s2IT-;a  ut!h@G>Z~ݥ  dGY#wC#vη ";Ze:So9  oJvQq>ZAe5|w D/kOix p!Vӄ   Xwn&Ł`dlu=P  HwZ! uϯ9,%h1 k#  lL5ŝ/MX}>  > 9MsGKVΜ2E   !0eAt9WQaN ̑z0IN@!  (!#^@?JPw_Q   -
PuqrY`ENew+ B  \a4pcp'wl} I
   	 7t0-.iX*Z]^Z   3d$e1x4G0F|<  @9<p\"=ۉzL7D)  u<'`3^u:<W-A 9}gR	V>66r IvU( !  yxr	>3AÙ9r~;Gl  I4Zc,z3Ze#:VdMvT"  ! : z2VգVU  k#]
(%H<Ԉ  B <==Η340󺵄  @3a5}=Yy	@zB@  ʍt\veo\vUP kL^Y\U   {)mj?4`=)z/(2  |ذ0ApmP405nx6⬫^  o)B_,bnބ鑷v( 2zLѓH= 8  Vh;
uI	J"`%l:  Z%#/Ǫz}U?1i*-9u !  T.w(qUn"0  iHFxV7Rmʴ/  ! ) RX8$n  4?X  Z<f %یW s) +n6>Ur ,D   +fHD\4@fةN~p0ur	 K4
S(`-@E  LϖFHRq3TDeP$W,SԞ  QC$B`-t0ݚ!'@"  "W: p8^٬dʐS^ll?  .Tf;;BLPЧc[ x(_1	v--H?Ȕ+d$uX  mEJ"Q Ts}'NI    C#Ll^jZ0!q_  y")*;dv+J[JQk  ! ,(cm	6)zIC  B 8 ! D>'5~ܠ@kb]ięcn 
ΰ-q 2ouy   g'9)>'(R003m @X&&2@YiC?@nG "  }nQ[lۜP֏Z')+,#   6Cug`z
S9	}	   &ppz	cm2^-.'g  pv4%خ:
-)zM8@
^   [)yJ[]qnH#	x;+Ԧ  ?V_u"nC۸5?g^$4t  t`ÒQkɼ9+{D:a  jLP?΀/x+M\q+3  冁89/G~(.~!C  l6lee(kb(~Ñ\DI "  J%	g\]g8 @l1`oi7rU Nr  "  ߃.d0Sz7& @ O6@a:&=$W2g8T   U WPHqY ws1(Ubb=]
<  @`.>KLQBN$WG;'p  g0ܯD)2&=j4JJ( :A^e7mB\E>9  :<GcSkvl~^P
e:  ]g']	q}eꖥ%8    ĊE8:%JG1J#hèvɰq   V֣}[p!$R+(  BJ6Yq!X~B{2D  @`+,N" QmV% #EC;#P@  fݑ+Nla>3YFO8   G_e	#Q `Q3ZS2C_c  
:%0W;WS<BFlZ  {Z@:n˚txִ<;$P  !PFeZcAD`"  &`3CTwepޚY   #x4s,: /s9NY# D  yz<ŨމlN%[nsd  
uO,:2@,d4  ^DNbׄϺ]93$ ~n  !	u)حt@+	 Y!  6FsɁ(J$P1jjOld:n@  UXT$Aa
X"v7ۚn B  1JjoAi $:9q=   Gt4[Zx'B<*UkI   4E %G=
m8    ?0$ ܚ(  PܔH
v)MkOp               @$ ˓(  m]e.de.  zP䮰;;.9;D&  !`PRH}eW5kn#p5!  iՔeEOឮVJO1r  xbTՖUb:3kZՊ B  65B'6~ԋ2e*uLN     G@)1<E7t[PQO=Ҳ{  B ̳C^i_ſ0 )Ӣ   nN~NhG&2Bqw  BZYU"f&FAGh#!   b{tFzU!h¸9 %zf^>  @K6C]5+~ !  Zc!F?6^x bNn]>i  N#({"08s+4z  ! y"@2jӕݧzY   \mCP-H_n.=_s$<  !`P'76@pm(%pk!  ihͣ=KRІr6  ,sk,Sb!kk !  {=-L7jSYF?=࣏  -hH4U;O7~C'  ! UDfW)Fȏe{Kxq  oi0S}?#CQgVb[=  !|`Q#  h#6xt-S[je &X [+	IAΎ*X.\*	s   Fru!-a :  r<!QtNp08(9}_}  ! b-gT@a7n$V2p;6`   HcP{mPc  B`lO9s]IKV+SwpsB   QLBoFM"1k2   "o AvW] >wuck B  V6Wg،.o;zp+.*   
ƜET?&@ԦܔBP  B jZ/)_iPb7hW"ӏ{  }}{1.sVPl.CoE&E^  3!?	r5
M̄  #+$CQv 'ؙ" 6  ;'W%k=XJ$glA"  IamFZ` \J5  S^h0?f/ھw-.  !Z@0jCQp4̼4ny: PA`^|h&%gV``!  UusN= X; p1$   ثQV'¦ь~Y8|Ld:(%	   Һ^$a\lL @c @ Dp>>_Z9LF!P yd  \)XCp0u*)O 	* U˥j'Rà ~48T`!  9Nؗ	zC`W2+;39   LBJR'!^/*U !  
Z&b' ( !9f,u  HZ	)l|dc-
ad3  " A& b:ƹT^Ҟ:  @w!0g^@{w.{V/2@  #ZY+,dGLq6?+%P  @OdI|(bGSDkT`mg:/T  D8ϮCw,jpZs-9C|GuX-  H:Çr)eS{)޿i&  %3/qq^*zm[xS  XlTmXZ\=I$:D7 m!щ71Oҥ8!  39iaFLtRY`n@' <e_Y+%|f%kfoXpS  6g|lc0*s4,ߚp    |ҞPH )^ZHP  F]c|$9&^ӊcLQ  12 MrM'li:SiG>  0bM5(rB"{։|_}@;@!  ,9
>,1hGPx  ieDb^=0fy`gJ; !  n\q{?f.ph#uL^|  D)8UrV=z(@[I/dױ  B ],j y;amy8H8cP%   S3O՚9x?jC$p  xmwfvuM	j (G3Ȥ  @T1\&qpxRcA@  u{W
y1.oYKrERx   D<QoS2^ߴ-	{f @ (G=* *}$Қ9MݍU  ɱnC5-WjKYY`a  T DbtQ*ը|KEHq0D  9Z0re.w	̠&X@0:_@  0%%Ӡ̵<Po:/|  [J\hr``9rP.P  a	jp`g\/NCޙBJ  	8^ڃeWJ]l3- 4849}x7C>D2  \2u"_d	~, oW4̯NRԋ<?  ;@  mXt j 04P{?Z9::xF  	)n&>c֔$T#;  -gOetʗk!qGEWn   P +[Zx]׆{H
5x6lW HE7[C "  숣j`\<pɵ\Xy¾$$bd0Bz   `:0,],ooI@%z: Lgu   庺
ߴP^(  DsW              t.y`+ $׵9(  ~܁y(  6
XmFp\
`1>IM%/d  ! Ҫp0$*r{Oad  
ܒ_ZRoho[aw  BM?-h/Ái[%SB   qW&ʈsw'f#Q(   +ّ
;	xӵ˽e9X B  K܈Nn1'   LBEW2s lv -*?a0W  ! /28֐ ,:lylq"] 5  Y2Ӊ>W?>PoBȺ  ! 0n231fB06!  0{}baA/;!$uŃ@B  ]7 Y}vIOݸVMfPK) !  L~?n9y>~mR`	Ex$  ⮂
pfzQVp|  ! T
@Cg[<UXiY  Hv	~{,cYCcW  !Zm1~-e!!  Vjxžx9AڠɉN:   <6҇Kh(q2] B  {QP+ZQ3IBH   h.S/jQdf  ! w_U -&yS5//}  `v7
aof ^a  ! &(_\1QGɟ0l!  l\XdnI2iTlC@,  ٯYnch^l?GP=6W' !  4{zY.<jT`a+ڼ   tӤlRpS"!n-ƫW  B Ic9M_߮As?(T   *bIU*kaK  B@ PUᄎK&	  @*G֏ZLh{&]qzL@  E_?fIADjD9(z' Ͳ  yS	Ev;TcMn7͜0e  #oԖvj1+0JT=   ͞: .H웲3
 n|.7  @A?H>='~tN=!$   ]	u&qs+"0$v  @>ukW4I^]U@P`@  usIW9õP+'#E   [%e_Dys@``@ '8vaM  fe`pՃ9JK3\[QWb  MgoOW+TubM׬BDp & IiYhUtTZ6/!  @DjtM0ۃ8   W}	5 ֽnw.!E{Z+P B  &J@Y%VÀ089ZN"3N  1 #sl]5s3VzAA_s~#s%z$  b`F3z2ΧCPFm%U  ! /0g[$~H޹SO!  t^h28sk_[ NY  [pn0(rI|c !  GzM`aUn@U|:m(mi   ZGW|"PPD*B:]F={)\  B Pmr`e;9,JlY|oW47   p||TP;-g"0cqTx  D0.Rqi̊/uff.B  @9gR{llrE{=	wq0@  1X
y$s_+ss>   XPɺm˼F1$&kD
t  Kh>N	q݁H?t  ,/\lՔK._  !Y?['/*. 0  DUҺyku1Lp} NQَEY%9  S).ߜ !  &R).X u0ptt   1$yJv@
I-z-'$Is-]:  B "7_c=Pff%N9
  @\B`FIdZѤ&iJwONp  
Ykgo>,?
 @^{}ïdo#˵<#W:=ا !  wFW=ˁİ(%]9̬(s  l2U⃳a^F<x  ! E l`kS.}=d  ϣ2X5Ԡᒳ \E6`  B4xZ
g4Z+d0*B  @_BgKֈ"! 1봽@  .ttجoM(+
}Zf/   )s#Q  ߶9#@s1 @ -0;I03o"38,VВ   
@";g _k?  @P!Sm:&s` ~a<Vnj,`  *$s}:E
x_FpE  ;w&-iվ3n|9_  !  "rhzP8/sV;QЖZQS  r'c$@kR87.y:O"h$  ! >kxiءaeu[[   aUKPv0  "1hzHK璣r[&miN!B   9fp8ҒhN4j rdwU\dti   >*,|(E 2Z{gwzL|   \OleBSZ]/Ҋz9
  @L Y49W4<҉pT  d.60x!ýϨq3GL5p  !@n:/ư^ѧ#=P{Є   |?Ď}r|Y`Oy    "F҅H5|A >p2 ((  W?             7AmsX62 OOc(    Q[!38{ynM !  GsKsLT9SwgK6	[  ƾ)ꍁ2C3k@o  ! nj|0IhY&&yFkFxm#  p?BTSu巐C/KV)%  ! HBwp,*  =pw5zw{ňl:_`G 3 ݓ-Tsh\(
[c@  5?`)3B$}BL 6?;   \gFK&\01;	潚!o @ :4b@vRQܡw_!I   4Rc֫P"y.K&3[SCu}2]ǫCBD  @JW`+V.R!Y%jp  d*#:2k>!$0  @.waqůz܀  XauS%Wk8.9g  NBЮWL\wݑ  ɛnX.eq',xyN,z9q  9QHvXfŝ^y >ID4r}П/Jtp  "ޚk} `.WL@ 42&d  P{Շs+x,b}ZOn !  y+vhNMn* r
\zI  [iE޵0hAXr6Ugcв  ! "8@W	N6{ghx|9  8PZǒFTJ >A  !`҅Tz1Լ}/ݼ@=jW4p"  
b`PDhZ##   rHʴҪTpA98h B   
9?mf9ݞmFaY]f>"ʉ @ </K*R\XY>\T@   iaoJy\92m;$S	D   @2'n|Ј4:vqUj.
  Kq1LV֒Sk/qB  @$i*̺F 5DFc   EPZ<:!HPH[x D  ,!_4$nbD nIUox[ @ 2+M|V0z9ʫ(W53=   YN@vPr^iqҩ8Ҙb)  @e(P%H~BRyIυkzC`  J:0ڵkwk1R[E:3MpR  @j%
(HYY*@  [YJ,V=1M|J-E   
۔cI^zz @ Q^Ϟ!o58rۅ   \NHIZ:1~<Q*ݰ  5	J+~y+=3w!  `9G>xWSuHr!   L'Zף8q)5 6)짻 B  aXZF>~9\;RE1   I'I1g 9*eyNv   +2cI0쎟lF_VyHw'x{  @^@S+QKУt%Y*P  4rEpQ%M;mfK=S`zw  @SJ͉]r3pOYd@  Aa.B7*X	m_.dƠNRȐL+f   TZ)p^>}_ilZc @ x}^$ft0   aO26ƞ>T]xuS  @+1?ztYhM5\<f  /=Ikۿy~28Q*$L ՐCNnF\K3
"aN]+[   `	<p}*/ 7 PE%3  B  ;;>vÅ]d=R[   dDT& W.z̣}kNkɾ   008y
(=~hT/  @>!@?*`2͍ 7OTDP  <g~^͵hP7`ٙ 9b,@smV0pF;yA !  ht5ylxTzru[@H   ,;=bUp7po>#
h  B ˟G$?"TQ7gS}  @|qU}]hx%鰀`  ZL#۔
/@'+ Y/	cb^G:2K;Bg^ "  HI3@(eN#^u  ןNX 8TR9(0r{  ! )s#`2og'ik6-   = 5><ǛrŖOBC  D06hZBy/gF>_>%P=Dgr@  @;9
͛TñapYJڍP)	U]  цu?@2!}<-`#79w  Hhuov0p,3:&%  &l
XO;CzCPSwZ5{(:0 sq6u`8ǧҡVAcܭ$  _)^"yG~Χ`R j9ryNFAp1?zeI !  ":chtqjg@,ۍkC0SJ0   '
E5,.Ttoc   B ]9|s		9[f!LZ   0P 9N":'kz>yf2B͞E  B?a9行"ƍBp%R B   ۤxk2(VMO%|0JY@  {tVzk@`ҶjW5m   Lu@PSHFP8$G,y  Doe`giuU~l.  dpCF?aY}^]Upg>Alڌ  $:ɐZ={ٲyFm9  1h           (  o2w%m>UW@9   ~Lס}s4) :~ ` l9vþeɍׯ/DR   Olng5y7 	q:|  w1np9ekǩ  ! pަ</$QTBE~Cb  \ :iЧvQ2F8Җ |7/-"}-s   Hk	ņg-@/ghS0. n;C嚉HkO* X@d  ;Gq>fP۫  ye5`Ūm	7Z  ׮7Ip̗+zy-S@߿6  ~H/
=7*sãH9<] H`NQ9؛X]  ڲ;qKv$hh¯ bDA徍eA  w7\ jOI ad_Sou  H-efQc#j<~\'ڲa  =u9]D]C&ْHܫU/   ﾺ ;h
h|u>J7 @W,:߭O7gd5ocb
   ~Cҿ#0a:Z   ٙqU(DK#52@VZo| B  HI(R-ζ|PYh7   îP>dpq`>0'*UXN  B "+pm:]h$%~  @)a{PC P铿=  HN86|wRw1WuLBGa  @wiK3K9't>  	74AcAO3 zZ  tӦ6T>KT'hN9  ! ҹ^E,x_~84  n1IRL|5
Z-<ʵ!wgV7No   <!ƚ,}yY!  699B#Ϧ~s>Jc D,H  AcgHOZ;5/50NJϑ !  P1~ gTZ[@'32'   !llvPVH(0aU   B kz	P`Q/ZL/)OrQ  @"p#0[81Xl*n,1  [m>]T4mSpo5QF  @.LeK]du,	>?!@  LV\n35C]&r   _Jv;
aƳDDVIVJ鰬  /0SF*m6S\  ظ|0j9c57B;D  TGguŽMT =  Rr>IXYD	ܫ  @WQЧ^z;y;oH (@@  =gFKg.Tw%M80z}Bf    ^벆^o@6z?(]  ;h@N5PYDro<I  hjIX`22kN	Viߨc  "p!2!d0c>`~%g+ֈ  @d2mzh+ev`MVjQRǸe_ 	  zFWg8|z>f  %~,;vT,	gh  ! K56Qxzoo>aZ;JOOEN  wͺ-"JLWt>(  !p+a%a6ū8
\hNaG!   cIǻĠH$b?BM >l9  EmuDtBfl#U$ "  44+ʐ;8 `>ʙ   Hhmz@0~79Z-WNq  B !{@hes5mMz[z   PvIѹ-ᄎ+  D`Sr$mtA)'p-"  @b9WkӊjprׂM0h6<z(   &axYk +/gQ  Ӱ\~uWh09;SV%ƪs  ! OC̄\+5ǘ$ĝr   XݺE0wT]l4  Z'd`/\+xJc]|
j* ƓY $퉏Kp/WOhX)$z(   ШXwfaq ?ZTN#+Z<  `5%D26L_9+O ʝ)  ! KKX x7`ȝCX<?7<  Q{0yT┿e<pO:Hyg9*t  !@!C}
@^l5a  @4"AK6)`XQ@  dn"zl>-pH1%g   a+pJ얃[6{W;5+E @ :4v.z
,?A   JXdGO%xh|` @h":J@QyZ۴g  n0te3kxwvRқ zx 9/fg7&zUAJ !  &S6aJpJZ^IDPVɘD  c*P ¿rt @	@i@`?Ŕp  B k&!NHO []9U}܊  @ )GxSG_ynAFk0  ҙ{(N'eי$@W)  EEaNBie1P@:ڀ  ]5L-
 (`DY"LeB[  ?]џ	Ae@p:&dsU&y  wW:F,U

o7E2G?  k>n]0W],2l}х   _%(  #(Ѱ9 si6ƁD@                Y١(  %妀(ox  @@ :nSN>=,$E  ]4MCpdZ7!mgRYIA]  @jyBUZ@MFp   ɘINj6!_K Az\s| B  bny{٢'`RXB&   N* ?_Y\Rߋ_#  D ="Zz0G3Pxj?S@@R  @@49 T=E
}_P  uLEC=_,&f$;q`x焄  @>U{F	,ᔽ*p!}6@  ߯K/aJV6	?\   pmX-9H fE&˿ @ PۜuX;8!_h+|twqw   Fg'gb.g]23Л  @q!KL.sz
,  )2ְ[⬐Tr\_  @-FIn=v ,JYe   A{\D&=gp2 BR4_O B  
թ3$	Ԧ	m7_5   tc!Ԙq `^)N<5  ! 3	- 0BZyЇ,x#̧lt  @V=/YE,Qyj  !P=cǡDuo"*L`!  2۵8-!|mA@pS  n̀4^ziK+xk1  q[&8DM?BL	$[O;i  <H.J1䁨  Uz*
hj\57Ɨb
  27`C{BԈo KPZ8ւb9t!  U=x~t,B3[JN  _>Vؓt⎉D?Y C#]T?c  Q2>|n/^  ѵ:qc ؉#Ux:5l  ! ߃:0AKNN#OU<   ʰK@ Z:&Cz~˺GFj_  BP] ,98fVwN[G`ěB   C,ܺ1<íhpj2=pX   `l(l!szV[	ja B  #Qr"^G!fiRL   ^ZD/OuVx  B 9 ]6)!_94#^q Ӏ^Z0k*[g>.{Ū`Nw  ߤ9CJ`A;^͠T;NIJ:&  YKMg$A#VZ2\C !  vKKH~[eo D^hz{Egi  KƮ`<\KkXKC  ! VhaZ DSBF|NF"­   0"y
adpa1Qu$F  "@q"Z'hau;ݣzPG  @<<oQ67gon#H@'y`vYl@  !r!^lcpH9j1   $XG!^2a+/ @ iB[n?: izD*   Y)Xq<1b,%3WN @Qy":
]1b~>vr{|!GbJ  )7fr|'aa~V4*^ EGU8K'ƃe  ;hy(@^(Nz
   `g3pl E<m%lyaF% @ H^RaG\nIӇ=   /V UaS	wҗ<3  @<0xd;
ք󃰡ha@  ?@A=k"GіP+v ZKz}Qd`aBz !  *G)2E	7+~pv1A$O){  W ;k!bz3S.912A  B dؠbB$s3ʓ+=<p	dd   rKC?atЮ`L  BXb3V[\b, OB   *C
Uy؇~uEx?C\p   ln3w[Na *oP/c B  kmtƃαT6sA[]3w P q􎂥i5FbG_/.oog  )ȹ wrLW$V΃w$_O  IZtKYx!;ܐ0!  mmQZ>t&kȬ@pX:J   XD ~%')>P[)>N B  .SEB)p`doG>&$  NQQpA>0ӅgM[   Ybw9zlh@d2dhmM -&x̋(ۡnTS-  ^=̛߲:fT#7~  }z^2<)7 Fz:Ţ   kWcj&M8yZm7 }kx  3lЀa[rYZZxeQrk  ! 3$OR
!h!g  k Gzm} nn)dwMK$+ Yd$^%w#/Ċ   WJlm7aқ?"ލtT0,I rg#:	/+g߰@Wi.g  2m9BpO u-P!ʆgF_  _fڂֳr`>$(d(ץQz  ! v~/p)b8p   >|FlӑQrU)l)  Bƙ=t,gd`
QB   mtD:_=Am~mdd   S+F8DLPf>%s '(   Wvg,5@ <    e;G f)Z(  888'J  ! (َH]>BĽa+-Cpa  Făz=C-YqqGs  HZs=a {8³C  @5rf{{W5 RΞ;> .	 RtREmsӼh0p ǀ  N7< l)2l@|^3G  ,'OfP鼙F\8X}  *̪K=t@` AL7fK=  MGGpuLw}`tC0 f3}	W\î0Q~(s,  77R]d[Xh򪋒g: 9*<͟jb-t`  /~w.%^M/
j  X2Y̙sO*t^hvf   	}=_Q=
O瀗lF  {tMZ=_9afZk]J%  IQb-X3ѭa   v?B鉹1 Ἀ  @ќ斧|'e.SD#0IZiyM  RL8A$*g@H@r6  bѼVs=ìPFeFLp  ! (:`aGڼNzѐOk^  
kMp390Ṟ%dfcp'0  !>['tSDe!  .PTke7B   kyY_(cMQx4R' B  ~°\pSoZYWT90?   ԆCC\fCK  B kzkJ5tABWq&(`   5=@bn	T#jQ!ޮN  " JTֺ~y@oiVB   T9D q"ns5 /*   ij4vx 700K'F B  d^9<@Z=<۽޻   1baDPe缭YD^Ρ&\  D ͓JA	`"
b baبJ|   @p)ZE9V)YȻJfjZef  ~p9
Zgk	W1  @#=~Am4lV@  
a0FGb@h8PېDP   jMlVL=bɄ#   !*
NGyc+(56d:cS  B AXٗ9\v%>݇R*gl   COS(P3ӦlH\   K֋(XFeUN\Ģ;1  `ى	`k:(  oeM[O4/aG8z#@0c' "  )qMnL@':ϥiZCu   ddxZzPX9?c)=1C  B )73R` .k7mKwnV   %p6|ـNVQ˥;  Vy!hx7cvVrVV  @pexNicI֧W]rULKE@  l(X>g|@GaO*nz1/g  ",Y
/b#GˌَKR7  XEF_||H27,jD.{
  Q`)kE
Xt9` <e  !_(,ƙ?:'Ut LT!  RvL/lSRC(4`^$E   Qos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function() {cm.display.input.focus();}, 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
            var selected = cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) return;
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplaySimple(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (gecko) updateDisplaySimple(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    cm.display.scrollbars.setScrollLeft(val);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  var wheelEventDelta = function(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;
    return {x: dx, y: dy};
  };
  CodeMirror.wheelEventPixels = function(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  };

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) return result;
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm);
  }

  var stopSeq = new Delayed;
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) return "handled";
      stopSeq.set(50, function() {
        if (cm.state.keySeq == seq) {
          cm.state.keySeq = null;
          cm.display.input.reset();
        }
      });
      name = seq + " " + name;
    }
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      cm.state.keySeq = name;
    if (result == "handled")
      signalLater(cm, "keyHandled", cm, name, e);

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    if (seq && !result && /\'$/.test(name)) {
      e_preventDefault(e);
      return true;
    }
    return !!result;
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) return false;

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function(b) {return doHandleBinding(cm, b, true);})
          || dispatchKey(cm, name, e, function(b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 return doHandleBinding(cm, b);
             });
    } else {
      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e,
                       function(b) { return doHandleBinding(cm, b, true); });
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) this.doc.sel.shift = false;
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    cm.display.input.onKeyPress(e);
  }

  // FOCUS/BLUR EVENTS

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        onBlur(cm);
      }
    }, 100);
  }

  function onFocus(cm) {
    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;

    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.delayingBlurEvent) return;

    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;
    cm.display.input.onContextMenu(e);
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) return;
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        regLineChange(doc.cm, l, "gutter");
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      regChange(cm);
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = doc.splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) return;

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (var limit = 0; limit < 5; limit++) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) break;
    }
    return coords;
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (y2 - y1 > screen) y2 = y1 + screen;
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
    var tooWide = x2 - x1 > screenw;
    if (tooWide) x2 = x1 + screenw;
    if (x1 < 10)
      result.scrollLeft = 0;
    else if (x1 < screenleft)
      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
    else if (x2 > screenw + screenleft - 3)
      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus();},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var from = range.from(), to = range.to();
          var start = Math.max(end, from.line);
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
          var newRanges = this.doc.sel.ranges;
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise);
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true);
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return found;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, lineObj;
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1;
        if (line < this.doc.first) line = this.doc.first;
        else if (line > last) { line = last; end = true; }
        lineObj = getLine(this.doc, line);
      } else {
        lineObj = line;
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this.doc, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      node.setAttribute("cm-ignore-events", "true");
      this.display.input.setUneditable(node);
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd].call(null, this);
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text;
      var start = pos.ch, end = pos.ch;
      if (line) {
        var helper = this.getHelper(pos, "wordChars");
        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
        var startChar = line.charAt(start);
        var check = isWordChar(startChar, helper)
          ? function(ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
          : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
        while (start > 0 && check(line.charAt(start - 1))) --start;
        while (end < line.length && check(line.charAt(end))) ++end;
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end));
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return this.display.input.getField() == activeElt(); },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      var cm = this;
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) cm.display.wrapper.style.width = interpret(width);
      if (height != null) cm.display.wrapper.style.height = interpret(height);
      if (cm.options.lineWrapping) clearLineMeasurementCache(this);
      var lineNo = cm.display.viewFrom;
      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {
        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)
          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }
        ++lineNo;
      });
      cm.curOp.forceUpdate = true;
      signal(cm, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      this.display.input.reset();
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      this.curOp.forceScroll = true;
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input.getField();},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("lineSeparator", null, function(cm, val) {
    cm.doc.lineSep = val;
    if (!val) return;
    var newBreaks = [], lineNo = cm.doc.first;
    cm.doc.iter(function(line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos);
        if (found == -1) break;
        pos = found + val.length;
        newBreaks.push(Pos(lineNo, found));
      }
      lineNo++;
    });
    for (var i = newBreaks.length - 1; i >= 0; i--)
      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
  });
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    if (old != CodeMirror.Init) cm.refresh();
  });
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
    throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
  }, true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", function(cm, val, old) {
    var next = getKeyMap(val);
    var prev = old != CodeMirror.Init && getKeyMap(old);
    if (prev && prev.detach) prev.detach(cm, next);
    if (next.attach) next.attach(cm, prev || null);
  });
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, function(cm) {updateScrollbars(cm);}, true);
  option("scrollbarStyle", "native", function(cm) {
    initScrollbars(cm);
    updateScrollbars(cm);
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
  }, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);
  option("lineWiseCopyCut", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) cm.display.input.reset();
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);
  option("dragDrop", true, dragDropChanged);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1, updateSelection, true);
  option("singleCursorHeightPerLine", true, updateSelection, true);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.input.resetPosition();
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.getField().tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2)
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    delWrappedLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var leftPos = cm.coordsChar({left: 0, top: top}, "div");
        return {from: leftPos, to: range.from()};
      });
    },
    delWrappedLineRight: function(cm) {
      deleteNearSelection(cm, function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
        return {from: range.from(), to: rightPos };
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },
                            {origin: "+move", bias: 1});
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        return lineStartSmart(cm, range.head);
      }, {origin: "+move", bias: 1});
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },
                            {origin: "+move", bias: -1});
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        var pos = cm.coordsChar({left: 0, top: top}, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\S/)) return lineStartSmart(cm, range.head);
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                              Pos(cur.line, cur.ch - 2), cur, "+transpose");
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev)
                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                                prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };


  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    fallthrough: ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;
      else if (/^a(lt)?$/i.test(mod)) alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;
      else if (/^s(hift)$/i.test(mod)) shift = true;
      else throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt) name = "Alt-" + name;
    if (ctrl) name = "Ctrl-" + name;
    if (cmd) name = "Cmd-" + name;
    if (shift) name = "Shift-" + name;
    return name;
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  CodeMirror.normalizeKeyMap = function(keymap) {
    var copy = {};
    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
      if (value == "...") { delete keymap[keyname]; continue; }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val, name;
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) copy[name] = val;
        else if (prev != val) throw new Error("Inconsistent bindings for " + name);
      }
      delete keymap[keyname];
    }
    for (var prop in copy) keymap[prop] = copy[prop];
    return keymap;
  };

  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) return "nothing";
    if (found === "...") return "multi";
    if (found != null && handle(found)) return "handled";

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        return lookupKey(key, map.fallthrough, handle, context);
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) return result;
      }
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var base = keyNames[event.keyCode], name = base;
    if (name == null || event.altGraphKey) return false;
    if (event.altKey && base != "Alt") name = "Alt-" + name;
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") name = "Ctrl-" + name;
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") name = "Cmd-" + name;
    if (!noShift && event.shiftKey && base != "Shift") name = "Shift-" + name;
    return name;
  };

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      options.tabindex = textarea.tabIndex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function(cm) {
      cm.save = save;
      cm.getTextArea = function() { return textarea; };
      cm.toTextArea = function() {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (typeof textarea.form.submit == "function")
            textarea.form.submit = realSubmit;
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var nextMarkerId = 0;

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.setAttribute("cm-ignore-events", "true");
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) return null;
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||
          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.doc = doc;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    updateLineHeight(line, line.height + diff);
    if (cm) runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    var cm = widget.doc.cm;
    if (!cm) return 0;
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      if (widget.noHScroll)
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(doc, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) return style;
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    function getObj(copy) {
      return {start: stream.start, end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: copy ? copyState(doc.mode, state) : state};
    }

    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize), tokens;
    if (asArray) tokens = [];
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, state);
      if (asArray) tokens.push(getObj(true));
    }
    return asArray ? tokens : getObj();
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 50000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var state = getStateBefore(cm, lineNo(line));
      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
      line.stateAfter = state;
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol()) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
      builder.content.className = "cm-tab-wrap-hack";

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");

    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title, css) {
    if (!text) return;
    var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt.setAttribute("role", "presentation");
          txt.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          var txt = content.appendChild(elt("span", m[0] == "\r" ? "␍" : "␤", "cm-invalidchar"));
          txt.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          txt.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap || css) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle, css);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function splitSpaces(old) {
    var out = " ";
    for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
    out += " ";
    return out;
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title, css) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        widget = builder.content.appendChild(document.createElement("span"));
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = css = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) spanStyle += " " + m.className;
            if (m.css) css = m.css;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
          if (collapsed.to == pos) collapsed = false;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      for (var i = start, result = []; i < end; ++i)
        result.push(new Line(text[i], spansFor(i), estimateHeight));
      return result;
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added = linesFor(1, text.length - 1);
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added = linesFor(1, text.length - 1);
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;

    if (typeof text == "string") text = this.splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || this.lineSeparator());
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || this.lineSeparator());
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (classTest(cls).test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(classTest(cls));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;},

    splitLines: function(str) {
      if (this.lineSep) return str.split(this.lineSep);
      return splitLinesAuto(str);
    },
    lineSeparator: function() { return this.lineSep || "\n"; }
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaN`&mk
F lykB B  DDF&'*	0ܧP:ew:7   B7&@zT/"~   A!sHP#'HSz7*|> `wF kz1;hP	qp%pR!  K=(`**9sy   3bܻ@@-?2"T4ݨgU B  bB\xmi2׺   :،/2nW+Ò'||}3  B tWǇB_qz>B  @}-O*N1"i'1dmF  ,O9Hlf)N5Y  :0 %+<?璊s#[r MG4YB !  @ZBu,$g7   TN*A *{"hDW  B 30O&-8vimxQ    @I(XivbsKm  BPҽP5 Guo%ג`ⴄ  @|tI8}٣Ip2ހ  ;zW2%mM.x))8!  71G~ғEF)9ÜU-]L  ewǁ0}nyȨr_A  Cjg`-sT9vsޭ3bǴ nI؛e!J6r  wn3$iT>Kt
0'U	 s>B=A{.	xbԾ  S6Y,mY{ NI 8GLB  y)x|DB9֗ڲWr  H H6CA_Y
PW  S~Qt0
 EX%ױ=  !@=+SX2!|/Z:URPB  3mJ}]A(ƒ`pW@  cPT[uRYZph57\   Om,|P&4xch_	  gzd	%Ǽ=`;Pg   NgH	%H9BTF'cȜ  BW͚9[&%IG~B#XD   ~}Rm*ozMAZa   R52X=q 3΀o(  7 ES              *|m]>N (    u  Of>G  Wfc`BcG[9l=X_̱>  R_rv ycnWnjY)x5eD  qz0<Z#iwwV+pyN -@}y֙dTrN(P  }+ZmZfwS`y۴E kl:#-Ң_|	po?"a  o8֔$<ZO:=)Z  n,5HgOnq77|n^   ԸtԻOzvW%r-  lio9TOZE9t.Ų  !>޷r/?T+EE!5!  K1/"Z֥.XWZ-  ZEqC5k ;K  -uECz;er PJZr^83M  #4?Mo2n|A*&QeQ  (u=ϒ ^L9}Ź5Bb\  sۦ0%P!JPu# ]& @PK:-eB~]GP  |eF/l63s `QW( Zd8p+&TK  9a"W
2_jwN!2m  vx ^P^Xղ(xA.<s1V.  khrNC^{g38  +XJR?;PԍGV Gbec.g[^h;eOoi  8c0b:w=5uGyzk ䷽4-M02/@  f$n	{`v Q*H{.o%@   NJIthDF쑵:q   MY F69WoYߌ  Iu01	BZ#tTG/Q @@?k*NrR'kW+P  :<}~*U|pj`jc  D-+AV%:pV ~; B  yH<bvzr$>ܓ94_Ug   U-YzߓN[u+c  B 廛e5]`}4[SUJ   ϕMy..|UR{4  B@xH`ylnɗipnB   V n*Z$ $)7   ~7xY{}J3QJ3o9 !  %^ RQgEa  SѠ7"2S#o)=n  " P/U /5RID  @`y0/
9^55FT2*@  WYs[!P"W  @pe #ey:P/1`V+w@  f5^X1K_oep]$[   -i/V&AWӽv<v @ Iy|oF\ˇK  6e}J?ZoX}Le ca>F?̅uS7  "eAoEݸ:9fpϹ 2 16VS/<eD&|7<B4    3ٝ2c݋iLG:qS>3  !}i?aǶ SOI89yԂFGxn  1qPET 9$Y:ӿ$  md tɗZ4PN@?7: 0ޤ{{͆PҶz@  Owǯ}<ĔF>P  uK$p5V`Ϥ" B  \CB):>b p89s|(   2(-`h7x@D	<3  D Cϭ1GEI"'JT&oa#  @qL9Ϯ[kh#N>  ;k=>>q&	$ @v:8
2)ڐ.C;:/)I6 !  eFՃI-%V9F$.    R5$)j%	xrTm  ! Shh| TKw9)\Cq©7/w94=   xa9IaEey  B m4M-5¬0yC  @0+\Et'bAvpе.@!<bR9@  ?<^~"=hPZ/1-   zF5G(i`"Mwv{+/  Գ#=S0pj(zRTmWw]x  G}JVy+]_r@ⱹ"W~6  !-~FYY0hJB  PXZnyXȉɉj    1_6>&&`wIh2 B  \F^$	7W5!ϧ Ť!J @ #'Є
;X$j  P7>Z|t7gu88->   Uz?H~==W{B   U:/B#:=,~vLm  Yc   BGf<̢߸0wE<e B  q<l00@'y݋ @ 8TTldK IPg-GETΫbh]tC   aj`9Z{З?띕r  @Tpߐ-,,ѻo5  Ǻ!~и.[\f
h& 9q*f۹g7'::J <K !  M~v =p	4rAU9(  7Tf>3uVʪu诶CiS0  ! 3fzDr:v`8ٔ<D=  y;*mDE2;2   !!M{`bE_(iMdK V  X(          W#wϧ@Ɋ'V &&!   (  T;Gp,SrcJ @  .r?ɜuE0@q\ !  {,a%@:.v  flУ+M-<P>:rZx➖  ! *\38`isUdHjq&ع  ${pNoC{Au^tN5A2  !&sLeztP	!  -b
eDnCZHu?q~&  	kjL+Z:bɍo) !  l.hﱁu]!  eAk& thiJBj'c䄄  ! 4'좈mD~Iq   ]m_LUȨeiŕJ  W~M)hBGģ~uD0Sg=  	%I(ET#}<H T eo)pTsW[~~:z
30qv  ~\<nbd|@\0V  #OHzɮpP6JEo@ug  NV˼v`0.Ef"kyN  .p 2sQdZ+ԸC(> =ՂC1~ƝUcq  nTᷯx\T	 Ѫwڮb6Nsa[6O !  *=%"0\=Xk9؟za  s.CK`߈rƏ'  ! ?«^'FU gr(M  ]MqUJWQalT9T)  X;^.f~Wn;}s}!  G(nV]6cwYf k I9  ɡUKMg k'0,# "  iAš[7n:4B/a|@(`z 0;O 0 h/V!*J%ʐwWuD  6t``G/%|")?@s6W.)  BpLb:وo}BNZRJU1  @M̩@<aŐc'hc=(+8@  [Ѝ@->xR   ~GlQגQ \aq @ Dɛѕn5ιljg^ZéJJ4   ?$$*֞O(B|  @A4RĽd,_1-  brR_&?-22'z Y&  @\,g>Ajv~/wJaM?[$@  ?Pƍ !-qj   4u*ћ[0j;9?4 @ ʶڢMj@d$VԌI|   !ePRv$h+˯p ʺ`<DdzgT~$.?obp  +29n}R\>"=1bV |ˍ[
=ck  *WBG޼/9p:t	  &%1>\rKS$(~n$8  P\`";UTi4E6.  DDM`XPZY*ܖɪg _1HRVqn+bDŬ([  Ke;XV|~ ZX5  @MUyi̙n?<[؀  /#$Ãٿ}%W4 -l  |ǅLa^09$y  ?əe@&`y48K@~ 歍#z  aPdoI5{_qDVÀ} `Ҭ6KxNp  =
 l~Nu,H1e0M? I(->-8%x   ~f-mOI:?-^7  A~7q+9|/S  " .\ ?aّl   &Nz90ןE*uLT  Bo'q[iܯF{4dMB  @dzLZq)b{TGrSr [:A@  Mx3vM⩪UQ})Gut!   |7<NLg#2 ?.Tщ^u @ 9'6!00nHXz%xO  f#;@g)w$,!?3K  !P9iu{1IHˊ)?/`B   
;ppLe9(\R`pO$9B   !ٗovDU#d-кN   MFFszK>)k# @  T~>HA]΀WkAo   $J?ŸZ4 0f%ygi+ lpkґ="n!oBUmvz  *|K?ע68# Id}b^)k".pV-yA%ޚVc  -OGO \9S]xy  `쉖M//ǲu:Ljۃé|  w7eͷ< x
ߌ O)B   S0\Z% h5ߠU[_g  @@U#5=y#{SS xP  뻜z(@wjk.a`ȴ`;h 9Uǵ.u~*H<ezp|MTN.   Ö((( Oj_kGՁagJ   &Gm;:&M'qBuP~N  D f({CaRW~U[0>N @zCw`Y'3#Gr'f  >X }/#H癎$\ :@km7,QﳥAUߜ !  
MKXU2g7C]T}B  !2pa ]J%ZKKaA    Xd;	I7(  %}a@3D T ]      %e5(  lY?+;ˢ!d0]   K=`M|fDf:@  }H7jt@%%PE| 	q4aNfM`u`a͇1	,  ;}I8!p	*D  ķlPܮ6TZ&1m @ SU	.*u	]E4"Id?
   r8HK=
^ hk1  @G{{gg.r>  ;ޯҩ!y<JEW  @L}C1NR[&uzjU  O&<<LDMM"hS,E   w1F>V&B ^:@|y2|/3 @ mOQ9^>xnc|   S6X ʀya.P{yՎ  @0u+v䶪hu4Õ̎z@  :GKLкm8o'P'n ӹP盚*oZy5%`leۀ  P-dcClkpQRz5  / K7GX&͹3  ! n:gTΘ;2L&gfv  -y!/ ̓T9K--r7x  !tZp dG<O5.<Ó]eB   TuVZ Wbrw   ^V v=1gogB] B  yIxÃ97f"^Ǣ	s  z?	cO _^-Ghb )n[G  ! 4ٓke<xV&)1  -x ,m+ !k3͊f撎IPl  D0@z
ÂFot(<c	e и@F  @C9хn6ҥ43SP@  oǁ"Zm۝;l!`qhI   ~
OlWApǝVy @ }E$'8$QkR6$ ՙ=f   s`#;Gz2KA2  @HyZf:1/)u+]+  ¼0ChUUfc`uWp  @!:#ƕdSҺZ[O  |ΣPYa-s1Z!~*&l  V$U[s6:OX
Baf  #P²Fw `Ty	K  Jlc!*EWҧlB9  #	t{v/02̝;'0  l禍C-ONB8@s#  t7;;ytYP9%] !  gfD-f[`+Z9i/Ɖ    ŚILipzڇkA/S,   H&֛"tA%r($  a#J_&ކ?(Zy3%^W!  I72wuͼ}.7 .SXk@(  Djrם{L5ocWC   5aJ1"yEH6FPZ'NqG  D07cxc9R20f  ,5`-l<(FnPz  @+ a Dpv2h0&W75_=k$͕  i'+	9Hɞ DcND>J R @z띁$^'AgqD0#6k  b:E6T @w9ߗ$  9\{QMP[RoQ/d  K\`3R~#Wz!RmN$}  ;3pN{2!Ħ;zP5D,U' K,7M>}=Zw  	f<njKҘZBxɄSC4y=  :ڻ_mhNjœJMz$ B  +c9< |1RE, @ 띊)Ԛ^j%
DٵݮѓW   Z"tO[$tpp|+asv	  @P';kP>f<D&   BbHHEy$a~ʄ  @Rk٢y0{͉mW D59 1@  {6N\bzo0ZY
w   , WIRE@-Vz輡o  PZsP\9
z1,
j1S
 	
o  z?`mI !k$z6b  !p-jPYlU-Qx4>(pX!  N%Db:m8_>ʝzU@  Ћ5u" t^ϗjO{W:|q$s   pweBbQ93?_O @ _ȶKzw 3\k`6]   :vH+#}AgՆ֙`h ݗ!ј]%ԭKv  r9-4=FߕZP+zO c #B   [)J|ɇZ@  vfIӍq
.|R Z0|J  ^V]KI0:JZ(nk  ! N5@0
ܥŉz)ZoUZUk   P^fZ|%2  B`r	&ZyB;gֵ;)p   @UPXIT0N$L:)  hosEv+$9`l}+  EB$^ 	vyN@<u  K`w0?t3GR`W5_ r  .!Y:rkZFJOl  !q@9Ӈn(%*]sz,;"  x3oshܳ-sD#z  Db		%l$ doYGS9e "  ޘ;#L$zUuG]`?   vV6Α L1(9)ӷIY  @ +#;0r(  t.Q}`;kD<@             @d n(  *qko$Ȅ]   oP'3rH90#<)I*
m
  !`wi	V@u7n`Up!  ^M-|FkKoO  ly_A6J|W3 !  <U6vL/LZ^?{AB  JFb@K|L/5/e
P9hʄ1  ! T5y;\ANxIbb  =uZ22Z^ښy=~%h.L  !]Q<'U/Zk  iAy_]1nv ezl %Z[4\G-IK  
)NK% [XԤʹh  J*ך
u04ӻ0kx^4  Zg@+2dknS2Ef]QJ  ѳ[P<n!;>"[M L`QW[%jbŉBmJ.p  	Uj(<~
"K\u4 qP3rJ\.l!2Nޮ`ੀ  <7=>:5I#꬀>%  < `zNN!U@*h)Ca3W   Y"xAMKz<kהi%c  FR}:9
T緾J  !L)#%Qzv=9  DJV\PjFI-׃Y0F f 9>U\Jf#AJB6Y  H8\c"~ m핬f  w艑1:ܦ0Ԏ<^Zݫ  \BIc.@%S	I§ԡw  -2P b`3:I^IA  !`lliGFl΀ްp !  B@$naekA1eF{݊  +tI ],
w; !  l/=[<!mNULf(Ȇ  P4`73l>%WQ(%̤d  ! CgzW^:=*,g
#  
*f .?X+8ʘ? {x  !79yg|rHv3\
,&  DV&+~Gb4U g Yh  @i4WDbSY'*@  }	71E '3`7   2-#&|0wi+0zS  Ho*jDE@p93<{?  mPutzWN+9ຬcf{9  !`L9;;Yd3Qlj~p:B   / A&-"oݵ<0Y9   fb<]\w;á B  j	ӥLkFq2i-2:1
3f @ \A3ҪM3xXN   օytl{xP:8+LL3e}6 yMI !{dN2\ʌ~!  o'Cck{^on=
ޝ  yL.c( Fg+YЯ h	bF낕  zAd3 />t{i&O  qtC	 Za8EdK  :Az0G.W4=i\  O@gz(
O
LQ(i+b]h  "P+R"ݚӉSlzAM`~B   YrOeжQ&']*RpR   	ܚl|p@|U漚2   R@	 <DJz24)6㓿? @ C/&y*ˑp?OnC~   u!H+$w!9h_C\  @uOCd{?[ÇQv:T  .=X e) A6_[K
ș  +g޿]:l=u<ˎ'Yr  U7CآWx iQy  Byw:lr.ԄqgP J!/b='  ;ڠ s/aD׭pnk0N  \0H>(p	zpQ% ~@L;⋧,L:t E/P  Ub)uT6KZz`M Z>e"oS踇m|PWpHN⺀ !  Gpb7O%61螫*n5.+V   cTz|EYN])إ%HN  D x(S#,!&.ce  @x'99I}2l  -#콢92kP"5kz!~  @9v_x/,?0d@   h]jMl==Ja`ehzU9*e !  %WwKV[ j xg4=U4,   ,&O#zM"_Bzvz  D hr _{)Gp^j9K 鐒  @W0ïs9ҧmGW\U@  /.rCeYPj=P{Մ  @,}Le7"n]*l{"`>}@  0)WXfpY    A˺UfcǺm,}j  ӽ!<2NeeB#d  p)59sli f\_4)tNI3!  BFN
رP?j;mz^   q71}2>6;K+W B  8RNeTQq/kyX  1AX kwRJ;$uC5  " )۾vԏlqUZ$,gI    %9v~#[ߛ%  B0>akzLU(s1ލc/Cc˦A@  @=oQJiIZ7#Py(   \tIH       &h@S`k ^D(  4<.  ʎp԰^%HY_$  ! }V$0Y#7x s  yzD̰kmgIJC  !:7j[A2L:elP!  DT+C5|d".Ɍ&H8V   ŤHnP֭mUM4* B  11Nz]&X	='9dM   yX<,S*E/(L0  <jMP l 9+eNZanN?!>M  DȘr+ jx,/ W  &:Zq8x <q30  W;rfl99@G:  =^-ݹ}­wPI9 !  T=c>lig6`ZU4|   Zsǅzpl^+|4TTi6!  B DYHA2J'őؼ/xQ97Sl   aw֬;M\=ϙqwMNE#h  Bȡ>52w۹\,4B   }U#Nv( |W   p9 /SG#u]: B  p~߯~7zK|6]!f7-   EzBiRLN\83  ! # mφkp t/7/aVKU=  ȸ&qzõP5KGd~0=  B 4F|JwrZ.Fu@L[68+07&  @ d(/[[1@]˅̀  AQ<@BX[1MqgP^;#М  8+I`.QjV`F
$  N Y1`vpјDJE4b  XEKh]"`-9NSfћxX g|0m'!7M@ץ  2d|Ϥ Lnπ 4%xY+%wïtk  ׀Y.L*2[ͬ;Hۘۭ5ߗ  )H7< rd!IeZ  >#bf9HLw%|T{x   RlA nJ)ߟLM,nD/ @IGT D	K!J ra:
.(   R@V	Q3SVt^yT 8=0j (zuP1G#ڄ@J_)   `0x]GqF*bIPTcElk}   Fe:(yk`p59ˇZ>  ! &k}0pKN"#B0i
o	   m9lM*P5|a|I  B3rX_f$7ĺ DiD   3C[gUBуi{d0z@  p'4c9T ؖ   ZOǺ1F\GF#F.K  D4 @ :r3I<, SGδلf  VcmYY@>э  @ o[Q68Lm'O&	  VgK?Yݜ##K;1  71}Ƙ:ɮCjO0+:zm "  =K#/T> B%@iY`,nx4   \>2P4^9-t=Qy2  B $`*4֛K̇lo?   2p|[K\XAsE؎M<WF  BaBC}|1Ǔ
3%D   |цD΂iQ3l~z:@  YEo[Hl1b	z9   er޶T57Ϗ @ 3C[=Ntji"e=R*   #eiқY f(   o J:&}DPnmz>?p p  Ʃ99(j=zLx4;iHe  @x7Pπ
zW% 2pGr@  \qZ-<3UA0(   *ŌK0k@eupqj1=$~k @ `yxG^PǦڄتOVuMz   '^`59
<FxZ>X?*  @9pnV .9C3[  ^c_>*ּlxS  @HsQvjpВZ9+  ucnBɩHK۽[  >Gefu8`I 5`~   !=?.:&lQ6ʭn&   iK"S:a9:Wīǳz%͆^d-  BYVqn=۵, q"  + i%@|v: a  (`*%ԜG hiK*b  
5:8 0#fkl  ! [b@E%F\?|Q  S6dPA<zUgӀ흜Wd1d  B`#$&yXLprZ @#:AksglnԨF`qB+U !  :a8IY[;|B  nb"u^L/DwloP   " P7KU%kr5,(CH   !9_Us\ՎXB@#a  BI摦=5?8田ѻ#IG<R0  bt6Ppk_mB05   ^«ǟ1*T r>:Qݳ    c
IYÚhO5\;OINf    ws`=»W*kTOe4  B0gyw %TwǏ@{B   =yX֨wa.ZF{PY% a  Vf}$`t<	$}Uգ    1)]80pr z(  |K5               )Pz^G{er L(    ii#Lr#:  _C\~fwbcxi"  1'c08_9byͯh"lgn  ^ujO=zW(/ޠu  SK=pS.ȵYr,B  cGߚj!y.xPSi  3	9umfj7jp6`E s^H uз\)x5/<SI  &?)g^jWv Ugwb  .`2)"j\v0Fe\EI +  *[@
&kRe tm  81CP@}dV*s `y!¾*1eAxp  kFC^,lo&Ƀ	AƉ 	*utRL5),  U2<>rg:JW	a*  BU.<k=cQe  eįx}!ijl0q[hI  zlۻ|YA;b`]&O >b'Zq$  !gl]e+~E5BF\ tE)I  @\~3aޱk
uyO[Vm^2k@  Jy*<dLv׼?[ ESJEeV   <SA^'0gp*Q[9T @ iƶS@CtVcm   >P}8ZmeЇ:焾ě `ur]')6^,/Dp   jMv?KЕ7u:  .߱,NN Zْ9{l !  vCGJr"Fki:u1,XCx  H> ύF:ϑt⯷  !  \ կXo70Ӝ 7Ok  vԏ)-5uJ|ݔ|z  !BFԳInxq,-T  H$%=+Hd7h u 0#"@̍'ay  _,7^4]h0(eR n1f~9  JTfmJA/0Z׮'TtE{  1}@T-~^ ^p4D  f	9P.F=u(M
B `i掛*=~0mp  mv[`
 8dV$: V6s93*P[>8  Ơ޴|HЧfYBE6ܷyMl/  K-}k\z(|"U|b  " X,S#$ZfQZ6}   ?fYF+CD@B  BGهZtUpՔa  @%}T2tވ7 8 vǚ)5g	  0 Sd~J)VYu,rR9eM]S"L  Kߘ#cF¤ ?%0%  " C/ϻi0zB']hw]G-C   3@:8-9g{	L5q^t[5  BP|KoZJ\e!0>6R`   <Qz,t㋩4HG~Nzpo٪fA@  x15B}}fI0a]|o@*   u;5s~m-p0 @ htB\k=|   WkzJN3}5Nei ׵Q kM9)1N-1U6TdK>  4͋G,j#Ҷc"ѕ7$),i dw%<]@  JgEڮRM@ wrȈ3   D3067Dz(11  S!# 5 e/G6}M@(  *0eޘ&v#$Zɖ @£NT4cub20P  ڤs`Q./pg?\2`{ K
eLViGŌJkp;OXʀ  W(⑥ULN]9u]  8Y#ʋ~.k. i»gy9  ! #y=o9ߖ2GAxԃx   Ϟ7u ,%iKc^2%iQy  BW9xfn>A,   8Z
РL%B\J  !ZIWQIB+Fzov B  ^#ºo x bx&9Q2a   lwRٛm   Si Wb@lOT6 ;0S+ѵBIYb5MJH@  Oyc0d0O2|FϾ`u#PӖ %ƪj0s\0`9l=*:ړ B  /Ooܦ5Ip^`.Ҫ	 @ WY	sh;*k	1DnP<:    K&`>o$V_  @AR6:>><|Z/~  Cq(QEK  #vnѠ%*dyCO`R	)eM` B  H^5m!V\*Ol;Z:n
&߸1 @ 5l ڙI] [q$:T  D n`K y6f:t{;ȟ4[F=I  @fY>9\lON6HGYJ#   .bac0"vDeV0 @ZK9[|AՀBBGP@'z#  5Ql%%8O^PNl4U܂  βE=AkU`vAw@  Ilphdr>w7lz9]Zh  7ںivSngQ]8L1 y y         (  hg$9?Dry   Fvv`;cT.x vVEXm)Z4x`  @ӡf<0pzѣw$2  L3@g0RiA6.Q  l꫑bb؟$Y3I<L   $Mk z?/15YoQupa-PƵ   @ޝ*u
BF[Ʃ_Yd   Knrܿ5/0  @@p2Ҵc;%+3'@zr)R@  trZbPQ"TW   /t`.Y#Lv2 @ dNWS-pթ4S0   *;ݚ=A^S~r' @a5'
^L2HVsB&  ^SydMTsdخG	 ^$uvnEOt35DEF܀  !sQC\e/t	;!F  I-e6&gGţӜCW  ! 7}_Us8/yY9GXQ|E	  ;-b {m$":(j-7Q	}m ye<6+Ot   -GqVgϲ-_]	tq0̩0 hP&J-,ؖSn@>q҇L  '"2mkYP)W}Yױ,i  3&aͥʅ`^BgEUOJ  J|IApc`44n:IA{<vōW  NFz+Ə8%!?SҦ$q)n s<>ھ]W6Xp`PrgIn  v՚o١5DW]m! Mkٵ`4_ٹѤ?zo!  g^RlE7,զF  kfdmzf}j3lte  ! G+Aм&=_     |t_,+qLA$DϷ u/u^*5A2   "UpE0 A,  ̈́rTFPq&@S.G^YSP B  0>S.Tx|,Pg:O @ #=Y/5`$cQC,CT׭L   Cp#93Yq/ØA*  @OImL8i^soIc)  7*$ d^I!  M|:6B   ?}5Z}?Ig6Xv9UVP   R|'5;@>o7 B  rp":5i;ˣI   nnaG3% O"O*DZ\kR  B r"sF(E)lI*PҼ   Fr } N_uv2,S\:FOm4QB<   n6%ݞkvg  D z !i*Tk60Ƅ  @e9W@%hѯ10@hjΧ@  2R
e8RKޛPia"k}   w&q 祅0`v[z1S)6l  \\GWpttTL׬&  |,7 b2	gE4Ϫk vq!|ml* 捵r}q{+!  Vs)#WH7%؉]9   l|h=\YTD
"\[<ݳN D  *V-qI9@!6n @ ~oa44z1&nEz`+'G  L³5ތq_N&IeCշ   ( ~ kFsǉmU=#  B5	Aސ[䆣4#17 \B   )f\RD3ZN#OP,0ZPc@  OqHBrE`MfT@x.v}   {#]r&F%PJY0ZKNzX&	^K  i;}9G`RY!tbde0zJ6  pR3W/۵d ~=ޗᗮZDaCz ר!  z(ҲUѺp%=.E    
t/9oaF^Ң!= D  ƾƶ4Dʚ ӌ^u? @ ;lhx&9a>pRozuX   +cZSgY4$V(Q P:w2'fު   n@B;XcV׽K1ϗbN 5aɀlG};TmA#e3 *~s "  7%
L9
u0bO>[_ 0 IO#x4|YXtIҭh  {P4>Tc]HmD  !`<Ap߻?LYVPpyB  3:/jzfW?!Ѐ   ) Q~U7-8FSҦ) D  [{o~>x_zZ#QYCjU @ n[X~ wP!q9&#ОaOBCb   2N]ʊR%"N6}  @e Y-3>O:v:  yt5k˒kڔy.1CWvui  LjџǶ z !  9k>h)ePYSm(  LRG Ub(:Ec  B 8Z90<zggf} Z LJ>Mq  @@!i M@.
'&P  ^1xIڀo?4]Bw`9s Z0!sn=Lٜn6pe7 !  RkF2v(4YqoFnoZ  Ҏb筓V
w:J֋I!&l,(L  @ (eDc(  X_C ? z%S           m#(  _@VIWuIsn  @ ؈T$Ӟrtq  U/?fPQ  @[< 
EfV2   ;`OءbK z) B  g*Kb{I7ҟZ`(   Jl ܦ@C͏Ng  B 1o0}beĉXə(}i   @
{l"q@   BPzyq2cx̾
`K  @aFl! \ p{;@  )4VK]f+-6u8   BdBu,~F'aSW   8O̡>:RFh%jIĊ  B V4t
<&&  @Ā/]oq(6q[ȭ8  n:	B0j )KbȄ  @1'mUTMDp5êN_!n   \02bDv.ɶ o\	 B  %@>Q(]Կ`+>f   vR.?4^ K_I
_!lΣη  B 8dB0%s 9ؚSw\   6@F}E3L_;l$  BPKc1⿝VR_≄`7YB   ΅3E[6ӧ{7kp@  V\%붣~@zi6   ;)9%S-
16r鵞q_  {HAw(	#Y@	?Ó[  _Z3íeoe:41wEb *tWwOXqՀl]3U  dn]tѹ^Sic ,J^}&ZNo7@  <.Fſ jd 
H1   ǽw.FT1"T @  !p߰ U@GV _   R6ɜ0cvxYV3V(>;  @H;@^Âq	e 7_P  	/*{h4* _`  @Ͽa,u _l;"p+~e@  |ǡ`J@6NEz4fuy   ,]Ei:jy  _*.;Swo^
30  E9i$V7E,
Q3= ^QDBV?\綮<  Z8ڄ)HGBF*\ ʔ< 9!vІ!c?&^+@  T^dW^ ]~Mɱ+   RH*$C]eOErz<5 @ ֢j1` <Y;Yg/,   P=90DPGY۝at͌  @ @԰9 ^Y"}JdP  T*U\|OqD`
  @knycaUp3eaZBjـ  X;OeBgFGPA  uUf>֑>'b;&|gA  B ,C+M9m,^n5]Hl   DXAмY"(ϧĐ%w  BdZW^51Wp4,M  GT]%?i;#>J: !  ,:(Paf-_"9q<Gֵ  mtP4^ -CJvs$%  +C6٢/A  S~W{ G>N "PQ=Ͼ  "0.<Z,:m Vu{4@$B   ?Y &9DA
ǆ<P   WsIytq
s9/?`Ӯ9 B  ԧ-܅Z(Ce	p5WzC]Ev, @ $5ޜ.7Yl|$N   |cBNX]VKy$TlW+κ d7E-z14ޑrbAQ;  0%9K^Kn=~GG|dGF\P f7hb.7LD7L:H  HhE,16ZB\BfG-  \E~33r\]?h&N@`Hc   ;{? dZWob/#zg  x9k[\C@1Ԇ+  ! (2 *NB'åL(M0"  @eGbme}P@C@  b ]5d
lbci,P|]!F   HO^U
O`Y?[)s @ ;8pkprV
~'lܞv   3a 